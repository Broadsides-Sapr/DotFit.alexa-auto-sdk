From 15e062899bf2640e4d2400445bea80bb288947b1 Mon Sep 17 00:00:00 2001
From: Muni Sakkuru <sakkuru@amazon.com>
Date: Wed, 8 Sep 2021 12:05:51 -0700
Subject: [PATCH 1/1] Alexa Auto changes for v1.22.0 AVS Device SDK

For internal reference: b0c8e887
---
 ACL/include/ACL/AVSConnectionManager.h        |   5 +
 .../ACL/Transport/DownchannelHandler.h        |  14 +-
 .../ACL/Transport/MessageRequestHandler.h     |   4 +
 ACL/src/AVSConnectionManager.cpp              |  82 ++-
 ACL/src/Transport/DownchannelHandler.cpp      |  69 +-
 ACL/src/Transport/HTTP2Transport.cpp          |  57 +-
 ACL/src/Transport/MessageRequestHandler.cpp   | 142 ++--
 ACL/test/Transport/HTTP2TransportTest.cpp     |  10 +-
 ADSL/include/ADSL/DirectiveProcessor.h        |  15 +-
 ADSL/include/ADSL/DirectiveSequencer.h        |   4 +
 ADSL/src/DirectiveProcessor.cpp               |  25 +-
 ADSL/src/DirectiveSequencer.cpp               |   8 +
 ADSL/test/ADSL/MockDirectiveSequencer.h       |   4 +
 .../AVS/AVSDiscoveryEndpointAttributes.h      |   4 +
 .../AVSCommon/AVS/DialogUXStateAggregator.h   |   3 -
 .../include/AVSCommon/AVS/EndpointResources.h | 188 +++++
 .../include/AVSCommon/AVS/MessageRequest.h    |   7 +
 AVSCommon/AVS/src/CapabilityResources.cpp     |   5 +-
 AVSCommon/AVS/src/DialogUXStateAggregator.cpp |  35 +-
 AVSCommon/AVS/src/EndpointResources.cpp       | 223 ++++++
 AVSCommon/AVS/src/MessageRequest.cpp          |  10 +
 .../AVS/test/CapabilityResourcesTest.cpp      |  16 +-
 .../AVS/test/DialogUXStateAggregatorTest.cpp  |  68 +-
 AVSCommon/CMakeLists.txt                      |   3 +
 .../CallStateObserverInterface.h              |  17 +-
 .../DirectiveSequencerInterface.h             |   4 +
 .../Endpoints/EndpointBuilderInterface.h      |  20 +-
 .../MessageRequestObserverInterface.h         |   9 +
 .../Messaging/MessagingObserverInterface.h    | 129 ++++
 .../SDKInterfaces/MockDirectiveSequencer.h    |   4 +
 .../Utils/HTTP2/HTTP2ResponseFinishedStatus.h |   2 +-
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |  35 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |  83 +++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |  56 ++
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |  83 +++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |  56 ++
 .../AVSCommon/Utils/Logger/ThreadMoniker.h    |   9 +-
 .../AVSCommon/Utils/Threading/Executor.h      |  14 +-
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |  60 +-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     | 129 ++++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  | 129 ++++
 AVSCommon/Utils/src/Logger/Logger.cpp         |   2 +-
 AVSCommon/Utils/src/Logger/ThreadMoniker.cpp  |   5 +-
 .../DefaultClient/src/DefaultClient.cpp       |   6 +-
 .../CapabilitiesDelegate.h                    |   3 +
 .../DiscoveryEventSender.h                    |  13 +-
 .../src/CapabilitiesDelegate.cpp              |   6 +-
 .../src/DiscoveryEventSender.cpp              |  22 +-
 .../src/Utils/DiscoveryUtils.cpp              |  31 +-
 .../AIP/include/AIP/AudioInputProcessor.h     |   5 +-
 .../AIP/src/AudioInputProcessor.cpp           |  51 +-
 .../AIP/test/AudioInputProcessorTest.cpp      | 207 ++++--
 CapabilityAgents/CMakeLists.txt               |   2 +
 CapabilityAgents/DeviceSetup/Android.mk       |   2 +
 CapabilityAgents/DeviceSetup/CMakeLists.txt   |   7 +
 .../DeviceSetup/capabilityagent/Android.mk    |  42 ++
 .../capabilityagent/CMakeLists.txt            |   7 +
 .../include/DeviceSetup/DeviceSetup.h         |  71 ++
 .../DeviceSetup/DeviceSetupMessageRequest.h   |  67 ++
 .../capabilityagent/src/CMakeLists.txt        |  19 +
 .../capabilityagent/src/DeviceSetup.cpp       | 101 +++
 .../src/DeviceSetupMessageRequest.cpp         |  90 +++
 .../capabilityagent/test/CMakeLists.txt       |  11 +
 .../capabilityagent/test/DeviceSetupTest.cpp  | 208 ++++++
 .../DeviceSetup/interface/Android.mk          |  24 +
 .../DeviceSetup/interface/CMakeLists.txt      |   9 +
 .../Interfaces/DeviceSetupInterface.h         |  85 +++
 CapabilityAgents/Messaging/CMakeLists.txt     |   5 +
 .../Messaging/MessagingCapabilityAgent.h      | 513 +++++++++++++
 CapabilityAgents/Messaging/src/CMakeLists.txt |  13 +
 .../src/MessagingCapabilityAgent.cpp          | 697 ++++++++++++++++++
 .../Messaging/test/CMakeLists.txt             |   8 +
 .../SpeakerManager/src/SpeakerManager.cpp     |  22 +
 .../src/SpeechSynthesizer.cpp                 |  29 +-
 .../TemplateRuntime/src/TemplateRuntime.cpp   |   2 +-
 .../Endpoints/DefaultEndpointBuilder.h        |   3 +
 .../Endpoints/EndpointAttributeValidation.h   |   8 +
 Endpoints/include/Endpoints/EndpointBuilder.h |   5 +
 Endpoints/src/DefaultEndpointBuilder.cpp      |   6 +
 Endpoints/src/EndpointAttributeValidation.cpp |   4 +
 Endpoints/src/EndpointBuilder.cpp             |  35 +-
 .../include/Metrics/MediaUplCalculator.h      |   4 +-
 .../include/Metrics/TtsUplCalculator.h        |   4 +-
 .../include/Metrics/UplMetricSink.h           |   4 +-
 .../UplCalculator/src/MediaUplCalculator.cpp  |  10 +-
 .../UplCalculator/src/TtsUplCalculator.cpp    |  10 +-
 Metrics/UplCalculator/src/UplMetricSink.cpp   |  18 +-
 .../RegistrationManager/RegistrationManager.h |   8 +-
 .../src/RegistrationManager.cpp               |  39 +-
 .../test/RegistrationManagerTest.cpp          |   2 +-
 .../include/SampleApp/InteractionManager.h    |   2 +-
 SampleApp/src/InteractionManager.cpp          |   2 +-
 .../Settings/CloudControlledSettingProtocol.h |   5 +-
 .../DeviceControlledSettingProtocol.h         |   5 +-
 Settings/include/Settings/Setting.h           |   9 +-
 .../Settings/SharedAVSSettingProtocol.h       |   7 +
 .../src/CloudControlledSettingProtocol.cpp    |   7 +-
 .../src/DeviceControlledSettingProtocol.cpp   |   6 +-
 Settings/src/SharedAVSSettingProtocol.cpp     |  69 +-
 Settings/src/Types/LocaleWakeWordsSetting.cpp |  18 +-
 Settings/test/CMakeLists.txt                  |   1 +
 .../test/SharedAVSSettingProtocolTest.cpp     |  21 +-
 .../DeviceSettingsManagerBuilder.h            |  10 +-
 .../DeviceSettingsManagerComponent.h          |   2 +
 .../src/DeviceSettingsManagerBuilder.cpp      |  11 +-
 .../acsdkAlerts/AlertsCapabilityAgent.h       |  41 ++
 .../acsdkAlerts/src/AlertsCapabilityAgent.cpp |  54 ++
 .../AlertObserverInterface.h                  |  23 +
 .../acsdkDoNotDisturb/DNDSettingProtocol.h    |  12 +-
 .../DoNotDisturbCapabilityAgent.h             |  13 +-
 .../acsdkDoNotDisturb/DoNotDisturbComponent.h |   2 +
 .../src/DNDSettingProtocol.cpp                |  74 +-
 .../src/DoNotDisturbCapabilityAgent.cpp       |  85 ++-
 .../acsdkMultiRoomMusic/MRMCapabilityAgent.h  |   4 +-
 .../src/MRMCapabilityAgent.cpp                |   6 +-
 115 files changed, 4498 insertions(+), 376 deletions(-)
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
 create mode 100644 AVSCommon/AVS/src/EndpointResources.cpp
 create mode 100644 AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
 create mode 100644 CapabilityAgents/DeviceSetup/Android.mk
 create mode 100644 CapabilityAgents/DeviceSetup/CMakeLists.txt
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/Android.mk
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/CMakeLists.txt
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetup.h
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetupMessageRequest.h
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/src/CMakeLists.txt
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetup.cpp
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetupMessageRequest.cpp
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/test/CMakeLists.txt
 create mode 100644 CapabilityAgents/DeviceSetup/capabilityagent/test/DeviceSetupTest.cpp
 create mode 100644 CapabilityAgents/DeviceSetup/interface/Android.mk
 create mode 100644 CapabilityAgents/DeviceSetup/interface/CMakeLists.txt
 create mode 100644 CapabilityAgents/DeviceSetup/interface/include/DeviceSetup/Interfaces/DeviceSetupInterface.h
 create mode 100644 CapabilityAgents/Messaging/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
 create mode 100644 CapabilityAgents/Messaging/src/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
 create mode 100644 CapabilityAgents/Messaging/test/CMakeLists.txt

diff --git a/ACL/include/ACL/AVSConnectionManager.h b/ACL/include/ACL/AVSConnectionManager.h
index a66954ca..33faa2ed 100644
--- a/ACL/include/ACL/AVSConnectionManager.h
+++ b/ACL/include/ACL/AVSConnectionManager.h
@@ -176,9 +176,14 @@ private:
 
     void receive(const std::string& contextId, const std::string& message) override;
 
+    std::shared_ptr<MessageRouterInterface> getMessageRouter() const;
+
     /// Mutex to serialize access to @c m_isEnabled
     std::mutex m_isEnabledMutex;
 
+    /// Mutex to serialize access to @c m_messageRouter
+    mutable std::mutex m_messageRouterMutex;
+
     /// Internal state to indicate if the Connection object is enabled for making an AVS connection.
     bool m_isEnabled;
 
diff --git a/ACL/include/ACL/Transport/DownchannelHandler.h b/ACL/include/ACL/Transport/DownchannelHandler.h
index d650211e..e9f919c8 100644
--- a/ACL/include/ACL/Transport/DownchannelHandler.h
+++ b/ACL/include/ACL/Transport/DownchannelHandler.h
@@ -20,6 +20,7 @@
 
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2RequestSourceInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <AVSCommon/Utils/Power/PowerResource.h>
 
 #include "ACL/Transport/ExchangeHandler.h"
@@ -47,13 +48,15 @@ public:
      * @param authToken The token to use to authorize the request.
      * @param messageConsumer Object to send decoded messages to.
      * @param attachmentManager Object with which to get attachments to write to.
+     * @param metricRecorder Object with which metrics are logged.
      * @return The new DownchannelHandler or nullptr if the operation failed.
      */
     static std::shared_ptr<DownchannelHandler> create(
         std::shared_ptr<ExchangeHandlerContextInterface> context,
         const std::string& authToken,
         std::shared_ptr<MessageConsumerInterface> messageConsumer,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager);
+        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
 private:
     /**
@@ -61,8 +64,12 @@ private:
      *
      * @param context The ExchangeContext in which this MessageRequest handler will operate.
      * @param authToken The token to use to authorize the request.
+     * @param metricRecorder The pointer to the recorder used to log metrics.
      */
-    DownchannelHandler(std::shared_ptr<ExchangeHandlerContextInterface> context, const std::string& authToken);
+    DownchannelHandler(
+        std::shared_ptr<ExchangeHandlerContextInterface> context,
+        const std::string& authToken,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /// @name HTTP2RequestSourceInterface methods
     /// @{
@@ -80,6 +87,9 @@ private:
 
     /// The power resource to prevent device from going to LPM.
     std::shared_ptr<avsCommon::utils::power::PowerResource> m_powerResource;
+
+    /// The recorder used to log metrics.
+    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 };
 
 }  // namespace acl
diff --git a/ACL/include/ACL/Transport/MessageRequestHandler.h b/ACL/include/ACL/Transport/MessageRequestHandler.h
index 5c6f7dc1..c0bc0737 100644
--- a/ACL/include/ACL/Transport/MessageRequestHandler.h
+++ b/ACL/include/ACL/Transport/MessageRequestHandler.h
@@ -21,6 +21,7 @@
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
 #include <AVSCommon/AVS/MessageRequest.h>
 #include <AVSCommon/SDKInterfaces/EventTracerInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h>
 #include <AVSCommon/Utils/Power/PowerResource.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeRequestSourceInterface.h>
 #include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
@@ -142,6 +143,9 @@ private:
 
     /// The reference to @c PowerResource to prevent device from going into LPM.
     std::shared_ptr<avsCommon::utils::power::PowerResource> m_powerResource;
+
+    /// Status to be reported back to the @c MessageRequest.
+    avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status m_resultStatus;
 };
 
 }  // namespace acl
diff --git a/ACL/src/AVSConnectionManager.cpp b/ACL/src/AVSConnectionManager.cpp
index 142a3eef..8396c2ee 100644
--- a/ACL/src/AVSConnectionManager.cpp
+++ b/ACL/src/AVSConnectionManager.cpp
@@ -122,21 +122,37 @@ void AVSConnectionManager::doShutdown() {
         std::lock_guard<std::mutex> lock{m_messageObserverMutex};
         m_messageObservers.clear();
     }
+    std::unique_lock<std::mutex> lock{m_messageRouterMutex};
+    /* There is still a potential deadlock if the reset of m_messageRouter triggers a delete of the message router,
+    and that delete blocks on code that could call back into AVSConnectionManager and try to acquire that new mutex.
+    We can get around this by having doShutdown() swap m_messageRouter with a local variable while holding the lock,
+    and then resetting the local variable after new mutex is released.
+     */
+    auto messageRouter = m_messageRouter;
     m_messageRouter.reset();
+    lock.unlock();
+
+    messageRouter.reset();
 }
 
 void AVSConnectionManager::enable() {
     std::lock_guard<std::mutex> lock(m_isEnabledMutex);
     ACSDK_DEBUG5(LX(__func__));
     m_isEnabled = true;
-    m_messageRouter->enable();
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        messageRouter->enable();
+    }
 }
 
 void AVSConnectionManager::disable() {
     std::lock_guard<std::mutex> lock(m_isEnabledMutex);
     ACSDK_DEBUG5(LX(__func__));
     m_isEnabled = false;
-    m_messageRouter->disable();
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        messageRouter->disable();
+    }
 }
 
 bool AVSConnectionManager::isEnabled() {
@@ -148,39 +164,76 @@ void AVSConnectionManager::reconnect() {
     std::lock_guard<std::mutex> lock(m_isEnabledMutex);
     ACSDK_DEBUG5(LX(__func__).d("isEnabled", m_isEnabled));
     if (m_isEnabled) {
-        m_messageRouter->disable();
-        m_messageRouter->enable();
+        auto messageRouter = getMessageRouter();
+        if (messageRouter) {
+            messageRouter->disable();
+            messageRouter->enable();
+        }
     }
 }
 
 void AVSConnectionManager::sendMessage(std::shared_ptr<avsCommon::avs::MessageRequest> request) {
-    m_messageRouter->sendMessage(request);
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        messageRouter->sendMessage(request);
+    } else {
+        ACSDK_WARN(LX("sendMessageFailed")
+                       .d("reason", "nullMessageRouter")
+                       .m("setting status for request to NOT_CONNECTED")
+                       .d("request", request->getJsonContent()));
+        request->sendCompleted(MessageRequestObserverInterface::Status::NOT_CONNECTED);
+    }
 }
 
 bool AVSConnectionManager::isConnected() const {
-    return m_messageRouter->getConnectionStatus().first == ConnectionStatusObserverInterface::Status::CONNECTED;
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        return messageRouter->getConnectionStatus().first == ConnectionStatusObserverInterface::Status::CONNECTED;
+    }
+    return false;
 }
 
 void AVSConnectionManager::onWakeConnectionRetry() {
     ACSDK_DEBUG9(LX(__func__));
-    m_messageRouter->onWakeConnectionRetry();
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        messageRouter->onWakeConnectionRetry();
+    } else {
+        ACSDK_WARN(LX("onWakeConnectionRetryFailed").d("reason", "nullMessageRouter"));
+    }
 }
 
 void AVSConnectionManager::setAVSGateway(const std::string& avsGateway) {
-    m_messageRouter->setAVSGateway(avsGateway);
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        messageRouter->setAVSGateway(avsGateway);
+    } else {
+        ACSDK_WARN(LX("setAVSGatewayFailed").d("reason", "nullMessageRouter"));
+    }
 }
 
 std::string AVSConnectionManager::getAVSGateway() const {
-    return m_messageRouter->getAVSGateway();
+    auto messageRouter = getMessageRouter();
+    if (messageRouter) {
+        return messageRouter->getAVSGateway();
+    } else {
+        ACSDK_WARN(LX("getAVSGatewayFailed").d("reason", "nullMessageRouter"));
+    }
+    return "";
 }
 
 void AVSConnectionManager::onConnectionStatusChanged(bool connected) {
     ACSDK_DEBUG5(LX(__func__).d("connected", connected).d("isEnabled", m_isEnabled));
     if (m_isEnabled) {
-        if (connected) {
-            m_messageRouter->onWakeConnectionRetry();
+        auto messageRouter = getMessageRouter();
+        if (messageRouter) {
+            if (connected) {
+                messageRouter->onWakeConnectionRetry();
+            } else {
+                messageRouter->onWakeVerifyConnectivity();
+            }
         } else {
-            m_messageRouter->onWakeVerifyConnectivity();
+            ACSDK_WARN(LX("onConnectionStatusChangedFailed").d("reason", "nullMessageRouter"));
         }
     }
 }
@@ -228,5 +281,10 @@ void AVSConnectionManager::receive(const std::string& contextId, const std::stri
     }
 }
 
+std::shared_ptr<MessageRouterInterface> AVSConnectionManager::getMessageRouter() const {
+    std::lock_guard<std::mutex> lock{m_messageRouterMutex};
+    return m_messageRouter;
+}
+
 }  // namespace acl
 }  // namespace alexaClientSDK
diff --git a/ACL/src/Transport/DownchannelHandler.cpp b/ACL/src/Transport/DownchannelHandler.cpp
index 263f273d..ea3bacbd 100644
--- a/ACL/src/Transport/DownchannelHandler.cpp
+++ b/ACL/src/Transport/DownchannelHandler.cpp
@@ -12,11 +12,14 @@
  * express or implied. See the License for the specific language governing
  * permissions and limitations under the License.
  */
+#include <sstream>
 
 #include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/Power/PowerMonitor.h>
+#include <AVSCommon/Utils/Metrics/DataPointCounterBuilder.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
 
 #include "ACL/Transport/DownchannelHandler.h"
 #include "ACL/Transport/HTTP2Transport.h"
@@ -27,6 +30,7 @@ namespace acl {
 
 using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::http2;
+using namespace avsCommon::utils::metrics;
 using namespace avsCommon::utils::power;
 
 /// Downchannel URL
@@ -41,6 +45,12 @@ static const std::chrono::seconds ESTABLISH_CONNECTION_TIMEOUT = std::chrono::se
 /// String to identify log entries originating from this file.
 static const std::string TAG("DownchannelHandler");
 
+/// String to identify the metric source prefix for @c DownChannelHandler.
+static const std::string METRIC_SOURCE_PREFIX = "DOWNCHANNEL_HANDLER-";
+
+/// String to identify the response finished metric.
+static const std::string RESPONSE_FINISHED = "RESPONSE_FINISHED";
+
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
@@ -48,11 +58,59 @@ static const std::string TAG("DownchannelHandler");
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
+/**
+ * Creates a MetricEvent with the given event name and datapoint and submits it with the metric recorder.
+ * @param metricRecorder - The @c MetricRecorderInterface used log the metric.
+ * @param eventName - The event name of the metric to be logged.
+ * @param dataPoint - The @c DataPoint to be added to the metric.
+ */
+void submitMetric(
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    const std::string& eventName,
+    const DataPoint& dataPoint) {
+    auto metricEvent =
+        MetricEventBuilder{}.setActivityName(METRIC_SOURCE_PREFIX + eventName).addDataPoint(dataPoint).build();
+
+    if (!metricEvent) {
+        ACSDK_ERROR(LX("submitMetricFailed").d("reason", "invalid metric event"));
+        return;
+    }
+
+    recordMetric(metricRecorder, metricEvent);
+}
+
+/**
+ * Submits a metric when the downchannel stream is closed either because it is closed from the server, due to internal
+ * error or due to timeouts.
+ *
+ * @param metricRecorder The pointer to the metric recorder used to log the metric.
+ * @param status The @c HTTP2ResponseFinishedStatus status with which the downchannel stream is closed.
+ */
+void submitResponseFinishedMetric(
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    HTTP2ResponseFinishedStatus status) {
+    if (!metricRecorder) {
+        return;
+    }
+
+    /// Not logging cancelled metric because this could be triggered by user with a shutdown.
+    if (HTTP2ResponseFinishedStatus::CANCELLED == status) {
+        return;
+    }
+
+    std::stringstream ss;
+    ss << status;
+    auto dataPoint = DataPointCounterBuilder{}.setName(ss.str()).increment(1).build();
+
+    submitMetric(metricRecorder, RESPONSE_FINISHED, dataPoint);
+}
+
 std::shared_ptr<DownchannelHandler> DownchannelHandler::create(
     std::shared_ptr<ExchangeHandlerContextInterface> context,
     const std::string& authToken,
     std::shared_ptr<MessageConsumerInterface> messageConsumer,
-    std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager) {
+    std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder) {
     ACSDK_DEBUG9(LX(__func__).d("context", context.get()));
 
     if (!context) {
@@ -65,7 +123,7 @@ std::shared_ptr<DownchannelHandler> DownchannelHandler::create(
         return nullptr;
     }
 
-    std::shared_ptr<DownchannelHandler> handler(new DownchannelHandler(context, authToken));
+    std::shared_ptr<DownchannelHandler> handler(new DownchannelHandler(context, authToken, metricRecorder));
 
     HTTP2RequestConfig cfg{
         HTTP2RequestType::GET, context->getAVSGateway() + AVS_DOWNCHANNEL_URL_PATH_EXTENSION, DOWNCHANNEL_ID_PREFIX};
@@ -97,8 +155,10 @@ HTTP2SendDataResult DownchannelHandler::onSendData(char* bytes, size_t size) {
 
 DownchannelHandler::DownchannelHandler(
     std::shared_ptr<ExchangeHandlerContextInterface> context,
-    const std::string& authToken) :
-        ExchangeHandler{context, authToken} {
+    const std::string& authToken,
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder) :
+        ExchangeHandler{context, authToken},
+        m_metricRecorder{metricRecorder} {
     ACSDK_DEBUG9(LX(__func__).d("context", context.get()));
     m_powerResource = PowerMonitor::getInstance()->createLocalPowerResource(TAG);
     if (m_powerResource) {
@@ -147,6 +207,7 @@ bool DownchannelHandler::onReceiveResponseCode(long responseCode) {
 void DownchannelHandler::onResponseFinished(HTTP2ResponseFinishedStatus status, const std::string& nonMimeBody) {
     ACSDK_DEBUG5(LX(__func__).d("status", status).d("nonMimeBody", nonMimeBody));
     m_context->onDownchannelFinished();
+    submitResponseFinishedMetric(m_metricRecorder, status);
 }
 
 }  // namespace acl
diff --git a/ACL/src/Transport/HTTP2Transport.cpp b/ACL/src/Transport/HTTP2Transport.cpp
index c96ab241..8a442730 100644
--- a/ACL/src/Transport/HTTP2Transport.cpp
+++ b/ACL/src/Transport/HTTP2Transport.cpp
@@ -19,6 +19,8 @@
 #include <AVSCommon/Utils/Error/FinallyGuard.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeRequestEncoder.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/DataPointCounterBuilder.h>
 #include <AVSCommon/Utils/Power/PowerMonitor.h>
 #include <ACL/Transport/PostConnectInterface.h>
 
@@ -37,6 +39,7 @@ using namespace avsCommon::avs;
 using namespace avsCommon::avs::attachment;
 using namespace avsCommon::utils::error;
 using namespace avsCommon::utils::http2;
+using namespace avsCommon::utils::metrics;
 using namespace avsCommon::utils::power;
 
 /// String to identify log entries originating from this file.
@@ -70,6 +73,48 @@ static std::chrono::minutes INACTIVITY_TIMEOUT{5};
 /// Max time a @c MessageRequest should linger unprocessed before it should be consider TIMEDOUT.
 static const std::chrono::seconds MESSAGE_QUEUE_TIMEOUT = std::chrono::seconds(15);
 
+/// Prefix used to identify metrics published by this module.
+static const std::string HTTP2TRANSPORT_METRIC_SOURCE_PREFIX = "HTTP2TRANSPORT-";
+
+/// Metric identifier for message send error.
+static const std::string MESSAGE_SEND_ERROR = "ERROR.MESSAGE_SEND_FAILED";
+
+/**
+ * Capture metric for cases where there are internal message send errors or timeouts.
+ *
+ * @param metricRecorder The metric recorder object.
+ * @param status The @c MessageRequestObserverInterface::Status of the message.
+ */
+static void submitMessageSendErrorMetric(
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    MessageRequestObserverInterface::Status status) {
+    if (!metricRecorder) {
+        return;
+    }
+
+    std::stringstream ss;
+    switch (status) {
+        case MessageRequestObserverInterface::Status::INTERNAL_ERROR:
+        case MessageRequestObserverInterface::Status::TIMEDOUT:
+            ss << status;
+            break;
+        default:
+            return;
+    }
+
+    auto metricEvent = MetricEventBuilder{}
+                           .setActivityName(HTTP2TRANSPORT_METRIC_SOURCE_PREFIX + MESSAGE_SEND_ERROR)
+                           .addDataPoint(DataPointCounterBuilder{}.setName(ss.str()).increment(1).build())
+                           .build();
+
+    if (!metricEvent) {
+        ACSDK_ERROR(LX("submitErrorMetricFailed").d("reason", "invalid metric event"));
+        return;
+    }
+
+    recordMetric(metricRecorder, metricEvent);
+}
+
 /**
  * Write a @c HTTP2Transport::State value to an @c ostream as a string.
  *
@@ -638,8 +683,8 @@ HTTP2Transport::State HTTP2Transport::handleConnecting() {
         return m_state;
     }
 
-    auto downchannelHandler =
-        DownchannelHandler::create(shared_from_this(), authToken, m_messageConsumer, m_attachmentManager);
+    auto downchannelHandler = DownchannelHandler::create(
+        shared_from_this(), authToken, m_messageConsumer, m_attachmentManager, m_metricRecorder);
 
     if (!downchannelHandler) {
         ACSDK_ERROR(LX_P("handleConnectingFailed").d("reason", "createDownchannelHandlerFailed"));
@@ -747,7 +792,9 @@ HTTP2Transport::State HTTP2Transport::monitorSharedQueueWhileWaiting(
             }
 
             auto request = m_sharedRequestQueue->dequeueOldestRequest();
-            request->sendCompleted(MessageRequestObserverInterface::Status::TIMEDOUT);
+            auto status = MessageRequestObserverInterface::Status::TIMEDOUT;
+            request->sendCompleted(status);
+            submitMessageSendErrorMetric(m_metricRecorder, status);
         }
 
         auto messageRequestTime = m_sharedRequestQueue->peekRequestTime();
@@ -811,7 +858,9 @@ HTTP2Transport::State HTTP2Transport::sendMessagesAndPings(
                     m_eventTracer,
                     m_requestActivityPowerResource);
                 if (!handler) {
-                    messageRequest->sendCompleted(MessageRequestObserverInterface::Status::INTERNAL_ERROR);
+                    auto status = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
+                    messageRequest->sendCompleted(status);
+                    submitMessageSendErrorMetric(m_metricRecorder, status);
                 }
             } else {
                 ACSDK_ERROR(LX_P("failedToCreateMessageHandler").d("reason", "invalidAuth"));
diff --git a/ACL/src/Transport/MessageRequestHandler.cpp b/ACL/src/Transport/MessageRequestHandler.cpp
index f5d301be..fe89624a 100644
--- a/ACL/src/Transport/MessageRequestHandler.cpp
+++ b/ACL/src/Transport/MessageRequestHandler.cpp
@@ -86,6 +86,9 @@ static const std::string ERROR_INTERNAL = "INTERNAL_ERROR";
 /// Send completed
 static const std::string SEND_COMPLETED = "SEND_COMPLETED";
 
+/// Metric identifier for message send error.
+static const std::string MESSAGE_SEND_ERROR = "ERROR.MESSAGE_SEND_FAILED";
+
 // Key value separator for HTTP headers
 static const std::string HTTP_KEY_VALUE_SEPARATOR = ": ";
 
@@ -107,6 +110,10 @@ static void collectSendDataResultMetric(
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
     int count,
     const std::string& readStatus) {
+    if (!metricRecorder) {
+        return;
+    }
+
     recordMetric(
         metricRecorder,
         MetricEventBuilder{}
@@ -116,6 +123,42 @@ static void collectSendDataResultMetric(
             .build());
 }
 
+/**
+ * Capture metric for cases where there are internal message send errors or timeouts.
+ *
+ * @param metricRecorder The metric recorder object.
+ * @param status The @c MessageRequestObserverInterface::Status of the message.
+ */
+static void submitMessageSendErrorMetric(
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    MessageRequestObserverInterface::Status status) {
+    if (!metricRecorder) {
+        return;
+    }
+
+    std::stringstream ss;
+    switch (status) {
+        case MessageRequestObserverInterface::Status::INTERNAL_ERROR:
+        case MessageRequestObserverInterface::Status::TIMEDOUT:
+            ss << status;
+            break;
+        default:
+            return;
+    }
+
+    auto metricEvent = MetricEventBuilder{}
+                           .setActivityName(ACL_METRIC_SOURCE_PREFIX + MESSAGE_SEND_ERROR)
+                           .addDataPoint(DataPointCounterBuilder{}.setName(ss.str()).increment(1).build())
+                           .build();
+
+    if (!metricEvent) {
+        ACSDK_ERROR(LX("submitErrorMetricFailed").d("reason", "invalid metric event"));
+        return;
+    }
+
+    recordMetric(metricRecorder, metricEvent);
+}
+
 MessageRequestHandler::~MessageRequestHandler() {
     reportMessageRequestAcknowledged();
     reportMessageRequestFinished();
@@ -200,7 +243,8 @@ MessageRequestHandler::MessageRequestHandler(
         m_wasMessageRequestAcknowledgeReported{false},
         m_wasMessageRequestFinishedReported{false},
         m_responseCode{0},
-        m_powerResource{powerResource} {
+        m_powerResource{powerResource},
+        m_resultStatus{MessageRequestObserverInterface::Status::PENDING} {
     ACSDK_DEBUG7(LX(__func__).d("context", context.get()).d("messageRequest", messageRequest.get()));
 
     if (m_powerResource) {
@@ -324,8 +368,6 @@ void MessageRequestHandler::onActivity() {
 bool MessageRequestHandler::onReceiveResponseCode(long responseCode) {
     ACSDK_DEBUG7(LX(__func__).d("responseCode", responseCode));
 
-    // TODO ACSDK-1839: Provide MessageRequestObserverInterface immediate notification of receipt of response code.
-
     reportMessageRequestAcknowledged();
 
     if (HTTPResponseCode::CLIENT_ERROR_FORBIDDEN == intToHTTPResponseCode(responseCode)) {
@@ -333,6 +375,30 @@ bool MessageRequestHandler::onReceiveResponseCode(long responseCode) {
     }
 
     m_responseCode = responseCode;
+
+    // Map HTTPResponseCode values to MessageRequestObserverInterface::Status values.
+    static const std::unordered_map<long, MessageRequestObserverInterface::Status> responseToResult = {
+        {HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED, MessageRequestObserverInterface::Status::INTERNAL_ERROR},
+        {HTTPResponseCode::SUCCESS_OK, MessageRequestObserverInterface::Status::SUCCESS},
+        {HTTPResponseCode::SUCCESS_ACCEPTED, MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED},
+        {HTTPResponseCode::SUCCESS_NO_CONTENT, MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT},
+        {HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST, MessageRequestObserverInterface::Status::BAD_REQUEST},
+        {HTTPResponseCode::CLIENT_ERROR_FORBIDDEN, MessageRequestObserverInterface::Status::INVALID_AUTH},
+        {HTTPResponseCode::CLIENT_ERROR_THROTTLING_EXCEPTION, MessageRequestObserverInterface::Status::THROTTLED},
+        {HTTPResponseCode::SERVER_ERROR_INTERNAL, MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2},
+        {HTTPResponseCode::SERVER_UNAVAILABLE, MessageRequestObserverInterface::Status::REFUSED}};
+
+    auto responseIterator = responseToResult.find(m_responseCode);
+    if (responseIterator != responseToResult.end()) {
+        m_resultStatus = responseIterator->second;
+    } else {
+        m_resultStatus = MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR;
+    }
+
+    ACSDK_DEBUG7(LX("responseCodeTranslated").d("responseStatus", m_resultStatus));
+
+    m_messageRequest->responseStatusReceived(m_resultStatus);
+
     return true;
 }
 
@@ -350,51 +416,37 @@ void MessageRequestHandler::onResponseFinished(HTTP2ResponseFinishedStatus statu
         m_messageRequest->exceptionReceived(nonMimeBody);
     }
 
-    // Hash to allow use of HTTP2ResponseFinishedStatus as the key in an unordered_map.
-    struct statusHash {
-        size_t operator()(const HTTP2ResponseFinishedStatus& key) const {
-            return static_cast<size_t>(key);
-        }
-    };
-
-    // Mapping HTTP2ResponseFinishedStatus to a MessageRequestObserverInterface::Status.  Note that no mapping is
-    // provided from the COMPLETE status so that the logic below falls through to map the HTTPResponseCode value
-    // from the completed requests to the appropriate MessageRequestObserverInterface value.
-    static const std::unordered_map<HTTP2ResponseFinishedStatus, MessageRequestObserverInterface::Status, statusHash>
-        statusToResult = {
-            {HTTP2ResponseFinishedStatus::INTERNAL_ERROR, MessageRequestObserverInterface::Status::INTERNAL_ERROR},
-            {HTTP2ResponseFinishedStatus::CANCELLED, MessageRequestObserverInterface::Status::CANCELED},
-            {HTTP2ResponseFinishedStatus::TIMEOUT, MessageRequestObserverInterface::Status::TIMEDOUT}};
-
-    // Map HTTPResponseCode values to MessageRequestObserverInterface::Status values.
-    static const std::unordered_map<long, MessageRequestObserverInterface::Status> responseToResult = {
-        {HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED, MessageRequestObserverInterface::Status::INTERNAL_ERROR},
-        {HTTPResponseCode::SUCCESS_OK, MessageRequestObserverInterface::Status::SUCCESS},
-        {HTTPResponseCode::SUCCESS_ACCEPTED, MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED},
-        {HTTPResponseCode::SUCCESS_NO_CONTENT, MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT},
-        {HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST, MessageRequestObserverInterface::Status::BAD_REQUEST},
-        {HTTPResponseCode::CLIENT_ERROR_FORBIDDEN, MessageRequestObserverInterface::Status::INVALID_AUTH},
-        {HTTPResponseCode::CLIENT_ERROR_THROTTLING_EXCEPTION, MessageRequestObserverInterface::Status::THROTTLED},
-        {HTTPResponseCode::SERVER_ERROR_INTERNAL, MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2},
-        {HTTPResponseCode::SERVER_UNAVAILABLE, MessageRequestObserverInterface::Status::REFUSED}};
-
-    auto result = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
+    bool receivedResponseCode = MessageRequestObserverInterface::Status::PENDING != m_resultStatus;
+
+    // Map HTTP2ResponseFinishedStatus to a MessageRequestObserverInterface::Status.
+
+    switch (status) {
+        case HTTP2ResponseFinishedStatus::COMPLETE:
+            if (!receivedResponseCode) {
+                m_resultStatus = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
+            }
+            break;
+        case HTTP2ResponseFinishedStatus::TIMEOUT:
+            m_resultStatus = MessageRequestObserverInterface::Status::TIMEDOUT;
+            break;
+        case HTTP2ResponseFinishedStatus::CANCELLED:
+            m_resultStatus = MessageRequestObserverInterface::Status::CANCELED;
+            break;
+        case HTTP2ResponseFinishedStatus::INTERNAL_ERROR:
+            m_resultStatus = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
+            break;
+        default:
+            ACSDK_ERROR(LX("unhandledHTTP2ResponseFinishedStatus").d("status", status));
+            m_resultStatus = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
+    }
 
-    if (HTTP2ResponseFinishedStatus::COMPLETE == status) {
-        auto responseIterator = responseToResult.find(m_responseCode);
-        if (responseIterator != responseToResult.end()) {
-            result = responseIterator->second;
-        } else {
-            result = MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR;
-        }
-    } else {
-        auto statusIterator = statusToResult.find(status);
-        if (statusIterator != statusToResult.end()) {
-            result = statusIterator->second;
-        }
+    if (!receivedResponseCode) {
+        m_messageRequest->responseStatusReceived(m_resultStatus);
     }
 
-    m_messageRequest->sendCompleted(result);
+    m_messageRequest->sendCompleted(m_resultStatus);
+
+    submitMessageSendErrorMetric(m_metricRecorder, m_resultStatus);
 }
 
 }  // namespace acl
diff --git a/ACL/test/Transport/HTTP2TransportTest.cpp b/ACL/test/Transport/HTTP2TransportTest.cpp
index 7aa1287d..82d69add 100644
--- a/ACL/test/Transport/HTTP2TransportTest.cpp
+++ b/ACL/test/Transport/HTTP2TransportTest.cpp
@@ -975,8 +975,14 @@ TEST_F(HTTP2TransportTest, test_onSendCompletedNotification) {
     // Check that we got the right onSendCompleted notifications.
     for (unsigned messageNum = 0; messageNum < messagesCount; messageNum++) {
         if (messageObservers[messageNum]->m_status.waitFor(RESPONSE_TIMEOUT)) {
-            auto expectedMessageObserverStatus = std::get<2>(messageResponseMap[messageNum]);
-            ASSERT_EQ(messageObservers[messageNum]->m_status.getValue(), expectedMessageObserverStatus);
+            auto& item = messageResponseMap[messageNum];
+            auto responseCode = std::get<0>(item);
+            auto responseFinished = std::get<1>(item);
+            auto expectedMessageObserverStatus = std::get<2>(item);
+            ASSERT_EQ(messageObservers[messageNum]->m_status.getValue(), expectedMessageObserverStatus)
+                << "messageNum=" << messageNum << " responseCode=" << responseCode
+                << " responseFinished=" << responseFinished
+                << " expectedMessageObserverStatus=" << expectedMessageObserverStatus;
         }
     }
 }
diff --git a/ADSL/include/ADSL/DirectiveProcessor.h b/ADSL/include/ADSL/DirectiveProcessor.h
index 7b97895b..a4fd9c97 100644
--- a/ADSL/include/ADSL/DirectiveProcessor.h
+++ b/ADSL/include/ADSL/DirectiveProcessor.h
@@ -83,7 +83,7 @@ public:
      * @param dialogRequestId The new value for the current @c dialogRequestId.
      */
     void setDialogRequestId(const std::string& dialogRequestId);
-
+   
     /**
      * Returns the @c dialogRequestId currently in use for Directive handling. This may be the empty string if
      * Directives have either experienced errors, or have been cancelled.
@@ -92,6 +92,10 @@ public:
      */
     std::string getDialogRequestId();
 
+    void setIsDialogRequestOnline(bool isOnline);
+
+    bool isDialogRequestOnline();
+
     /**
      * Queue an @c AVSDirective for handling by whatever @c DirectiveHandler was registered to handle it.
      *
@@ -194,6 +198,12 @@ private:
      */
     void processingLoop();
 
+    void setIsDialogRequestOnlineLocked(bool isOnline);
+
+    bool isDialogRequestOnlineLocked();
+
+    std::string getDialogRequestIdLocked();
+
     /**
      * Process (cancel) all the items in @c m_cancelingQueue.
      * @note This method must only be called by threads that have acquired @c m_mutex.
@@ -295,6 +305,9 @@ private:
     /// Whether or not the @c DirectiveProcessor is enabled.
     bool m_isEnabled;
 
+    /// Whether the current dialog request is from AVS (online) or AHE (offline)
+    bool m_isDialogRequestOnline;
+
     /// The current @c dialogRequestId
     std::string m_dialogRequestId;
 
diff --git a/ADSL/include/ADSL/DirectiveSequencer.h b/ADSL/include/ADSL/DirectiveSequencer.h
index 64bb4031..e8808a9e 100644
--- a/ADSL/include/ADSL/DirectiveSequencer.h
+++ b/ADSL/include/ADSL/DirectiveSequencer.h
@@ -58,6 +58,10 @@ public:
 
     std::string getDialogRequestId() override;
 
+    void setIsDialogRequestOnline(bool isOnline) override;
+
+    bool isDialogRequestOnline() override;
+
     bool onDirective(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
 
     void disable() override;
diff --git a/ADSL/src/DirectiveProcessor.cpp b/ADSL/src/DirectiveProcessor.cpp
index 3ca3dd2c..c9a9971a 100644
--- a/ADSL/src/DirectiveProcessor.cpp
+++ b/ADSL/src/DirectiveProcessor.cpp
@@ -49,7 +49,8 @@ std::unordered_map<DirectiveProcessor::ProcessorHandle, DirectiveProcessor*> Dir
 DirectiveProcessor::DirectiveProcessor(DirectiveRouter* directiveRouter) :
         m_directiveRouter{directiveRouter},
         m_isShuttingDown{false},
-        m_isEnabled{true} {
+        m_isEnabled{true},
+        m_isDialogRequestOnline{true} {
     std::lock_guard<std::mutex> lock(m_handleMapMutex);
     m_handle = ++m_nextProcessorHandle;
     m_handleMap[m_handle] = this;
@@ -75,6 +76,16 @@ std::string DirectiveProcessor::getDialogRequestId() {
     return m_dialogRequestId;
 }
 
+void DirectiveProcessor::setIsDialogRequestOnline(bool isOnline) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    setIsDialogRequestOnlineLocked(isOnline);
+}
+
+bool DirectiveProcessor::isDialogRequestOnline() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    return isDialogRequestOnlineLocked();
+}
+
 bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
@@ -129,6 +140,18 @@ bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     return true;
 }
 
+std::string DirectiveProcessor::getDialogRequestIdLocked() {
+    return m_dialogRequestId;
+}
+
+void DirectiveProcessor::setIsDialogRequestOnlineLocked(bool isOnline) {
+    m_isDialogRequestOnline = isOnline;
+}
+
+bool DirectiveProcessor::isDialogRequestOnlineLocked() {
+    return m_isDialogRequestOnline;
+}
+
 void DirectiveProcessor::shutdown() {
     {
         std::lock_guard<std::mutex> lock(m_handleMapMutex);
diff --git a/ADSL/src/DirectiveSequencer.cpp b/ADSL/src/DirectiveSequencer.cpp
index 8a997f67..84c08d9c 100644
--- a/ADSL/src/DirectiveSequencer.cpp
+++ b/ADSL/src/DirectiveSequencer.cpp
@@ -69,6 +69,14 @@ std::string DirectiveSequencer::getDialogRequestId() {
     return m_directiveProcessor->getDialogRequestId();
 }
 
+bool DirectiveSequencer::isDialogRequestOnline() {
+    return m_directiveProcessor->isDialogRequestOnline();
+}
+
+void DirectiveSequencer::setIsDialogRequestOnline(bool isOnline) {
+    m_directiveProcessor->setIsDialogRequestOnline(isOnline);
+}
+
 bool DirectiveSequencer::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
diff --git a/ADSL/test/ADSL/MockDirectiveSequencer.h b/ADSL/test/ADSL/MockDirectiveSequencer.h
index 7773c70d..f0f3f01d 100644
--- a/ADSL/test/ADSL/MockDirectiveSequencer.h
+++ b/ADSL/test/ADSL/MockDirectiveSequencer.h
@@ -51,6 +51,10 @@ public:
         return m_dialogRequestId;
     };
 
+    MOCK_METHOD0(isDialogRequestOnline, bool());
+    
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
 
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
index a15c9454..d0c5c681 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/EndpointResources.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -123,6 +124,9 @@ struct AVSDiscoveryEndpointAttributes {
     /// A non-empty string identifying the endpoint manufacturer name.
     std::string manufacturerName;
 
+    /// An EndpointResources object containing friendly names, manufacturer name and description.
+    EndpointResources endpointResources;
+
     /// The display categories the device belongs to. This field should contain at least one category. See categories
     /// in this document: https://developer.amazon.com/docs/alexa/device-apis/alexa-discovery.html#display-categories
     /// @note: This value should only include ALEXA_VOICE_ENABLED for the default endpoint.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
index f35e2fb3..67b13123 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
@@ -42,7 +42,6 @@ namespace avs {
 class DialogUXStateAggregator
         : public sdkInterfaces::AudioInputProcessorObserverInterface
         , public sdkInterfaces::SpeechSynthesizerObserverInterface
-        , public sdkInterfaces::MessageObserverInterface
         , public sdkInterfaces::ConnectionStatusObserverInterface
         , public sdkInterfaces::InteractionModelRequestProcessingObserverInterface {
 public:
@@ -113,8 +112,6 @@ public:
         const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
         const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) override;
 
-    void receive(const std::string& contextId, const std::string& message) override;
-
     /// @name InteractionModelRequestProcessingObserverInterface Functions
     /// @{
     void onRequestProcessingStarted() override;
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
new file mode 100644
index 00000000..1bb0b5bf
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+class EndpointResources {
+public:
+    /**
+     * The constructor.
+     */
+    EndpointResources();
+
+    /**
+     * Function to add friendly name using asset id.
+     * 
+     * @param assetId The asset id of the friendly name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add friendly name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the friendly names
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the friendly name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the friendly name. 
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to add manufacturer name using asset id.
+     *
+     * @param assetId The asset id of the manufacturer name using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add manufacturer name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the manufacturer name
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the manufacturer name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the manufacturer name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to add description using asset id.
+     *
+     * @param assetId The asset id of the description using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add description using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the description
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the description. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the description.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to check if the @c EndpointResources is valid.
+     *
+     * @return Return @c true if valid, otherwise @c false.
+     */
+     bool isValid() const;
+
+    /**
+     * Builds a new EndpointResources with the configured properties.
+     *
+     * Build will fail if any attribute is invalid or if a mandatory attribute is missing.
+     *
+     * @return A json string representing the EndpointResources; otherwise, an empty string.
+     */
+     std::string build() const;
+
+private:
+    /**
+     * Struct defining a Label, used to describe a resource.
+     * @see https://developer.amazon.com/docs/device-apis/resources-and-assets.html#capability-resources
+     */
+    struct Label {
+        /// The enum representing the Label type.
+        enum class LabelType {
+            /// Asset type.
+            ASSET,
+
+            /// Text type.
+            TEXT
+        };
+
+        /// The type of the Label. 
+        LabelType type;
+
+        /// The value to contain the text or the asset id of the friendly name, manufacturer name or description.
+        std::string value;
+
+        /// The locale of the text, and empty object for asset.
+        avsCommon::utils::Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale> locale;
+
+        /**
+         *  @name Comparison operator.
+         *
+         *  Compare the current Label against a second object.
+         *  Defined for std::find.
+         *
+         *  @param rhs The object to compare against this.
+         *  @return @c true if the comparison holds; @c false otherwise.
+         */
+        /// @{
+        bool operator==(const Label& rhs) const;
+        /// @}
+
+        /**
+         * Helper function to convert a Label to a json string.
+         *
+         * @return A json string of Label.
+         */
+        std::string toJson() const;
+    };
+
+    /// Flag to indicate if there was any error noted.
+    bool m_isValid = false;
+
+    /// Vector holding @c Label for the friendly names.
+    std::vector<Label> m_friendlyNames;
+
+    /// @c Label that holds the manufacturer name.
+    Label m_manufacturerName;
+
+    /// @c Label that holds the description.
+    Label m_description;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h b/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h
index b9c4b2f1..12129eb0 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h
@@ -133,6 +133,13 @@ public:
      */
     std::shared_ptr<NamedReader> getAttachmentReader(size_t index);
 
+    /**
+     * Called when the Response code is received.
+     *
+     * @param status The status of the response that was received.
+     */
+    virtual void responseStatusReceived(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status);
+
     /**
      * This is called once the send request has completed.  The status parameter indicates success or failure.
      * @param status Whether the send request succeeded or failed.
diff --git a/AVSCommon/AVS/src/CapabilityResources.cpp b/AVSCommon/AVS/src/CapabilityResources.cpp
index 8905b8ed..7a6066c2 100644
--- a/AVSCommon/AVS/src/CapabilityResources.cpp
+++ b/AVSCommon/AVS/src/CapabilityResources.cpp
@@ -84,12 +84,11 @@ bool CapabilityResources::addFriendlyNameWithText(
             CapabilityResources::FriendlyName(
                 {text, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)})) !=
         m_items.end()) {
-        ACSDK_ERROR(LX("addFriendlyNameWithTextFailed")
+        ACSDK_WARN(LX("addFriendlyNameWithTextFailed")
                         .d("reason", "duplicateText")
                         .sensitive("text", text)
                         .sensitive("locale", locale));
-        m_isValid = false;
-        return false;
+        return true;
     }
 
     m_items.push_back({text, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)});
diff --git a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
index 57c2e89b..75196ef3 100644
--- a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
+++ b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
@@ -107,9 +107,10 @@ void DialogUXStateAggregator::removeObserver(std::shared_ptr<DialogUXStateObserv
 }
 
 void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterface::State state) {
+    ACSDK_DEBUG0(LX(__func__).d("AudioInputProcessorState", state));
     m_audioInputProcessorState = state;
-
     m_executor.submit([this, state]() {
+        ACSDK_DEBUG0(LX("onStateChangedLambda").d("AudioInputProcessorState", state));
         switch (state) {
             case AudioInputProcessorObserverInterface::State::IDLE:
                 tryEnterIdleState();
@@ -123,8 +124,7 @@ void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterfac
                 executeSetState(DialogUXStateObserverInterface::DialogUXState::EXPECTING);
                 return;
             case AudioInputProcessorObserverInterface::State::BUSY:
-                if (executeSetState(DialogUXStateObserverInterface::DialogUXState::LISTENING) ||
-                    DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
+                if (DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
                     if (!m_listeningTimeoutTimer
                              .start(
                                  m_timeoutForListeningToIdle,
@@ -144,9 +144,10 @@ void DialogUXStateAggregator::onStateChanged(
     const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
     const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
     const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) {
+    ACSDK_DEBUG0(LX(__func__).d("SpeechSynthesizerState", state));
     m_speechSynthesizerState = state;
-
     m_executor.submit([this, state]() {
+        ACSDK_DEBUG0(LX("onStateChangedLambda").d("SpeechSynthesizerState", state));
         switch (state) {
             case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING:
                 onActivityStarted();
@@ -166,12 +167,10 @@ void DialogUXStateAggregator::onStateChanged(
     });
 }
 
-void DialogUXStateAggregator::receive(const std::string& contextId, const std::string& message) {
-    tryExitThinkingState();
-}
-
 void DialogUXStateAggregator::tryExitThinkingState() {
+    ACSDK_DEBUG0(LX(__func__));
     m_executor.submit([this]() {
+        ACSDK_DEBUG0(LX("tryExitThinkingStateLambda"));
         if (DialogUXStateObserverInterface::DialogUXState::THINKING == m_currentState &&
             SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS != m_speechSynthesizerState) {
             ACSDK_DEBUG5(
@@ -201,13 +200,11 @@ void DialogUXStateAggregator::onConnectionStatusChanged(
 }
 
 void DialogUXStateAggregator::onRequestProcessingStarted() {
-    ACSDK_DEBUG(LX("onRequestProcessingStarted"));
+    ACSDK_DEBUG0(LX("onRequestProcessingStarted"));
     m_executor.submit([this]() {
+        ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda").d("currentState", m_currentState));
         // Stop the listening timer
         m_listeningTimeoutTimer.stop();
-
-        ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda").d("currentState", m_currentState));
-
         switch (m_currentState) {
             // IDLE is included for the theoretical edgecase that RPS is received after the listening timeout occurs.
             case DialogUXStateObserverInterface::DialogUXState::IDLE:
@@ -233,8 +230,7 @@ void DialogUXStateAggregator::onRequestProcessingStarted() {
 }
 
 void DialogUXStateAggregator::onRequestProcessingCompleted() {
-    // If receive() calls occur before onRequestProcessStarted() happens, we need to use this method as a fallback to
-    // exit THINKING mode.
+    ACSDK_DEBUG(LX("onRequestProcessingCompleted"));
     tryExitThinkingState();
 }
 
@@ -284,17 +280,6 @@ bool DialogUXStateAggregator::executeSetState(sdkInterfaces::DialogUXStateObserv
 
     if (newState == m_currentState) {
         validTransition = false;
-    } else {
-        switch (m_currentState) {
-            case DialogUXStateObserverInterface::DialogUXState::THINKING:
-                if (DialogUXStateObserverInterface::DialogUXState::LISTENING == newState) {
-                    validTransition = false;
-                }
-
-                break;
-            default:
-                break;
-        }
     }
 
     ACSDK_DEBUG0(LX(__func__)
diff --git a/AVSCommon/AVS/src/EndpointResources.cpp b/AVSCommon/AVS/src/EndpointResources.cpp
new file mode 100644
index 00000000..efe10619
--- /dev/null
+++ b/AVSCommon/AVS/src/EndpointResources.cpp
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/AVS/EndpointResources.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+using namespace avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("EndpointResources");
+
+/**
+* Create a LogEntry using this file's TAG and the specified event string.
+*
+* @param The event string for this @c LogEntry.
+*/
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/// Maximum length of the friendly name
+static constexpr size_t MAX_FRIENDLY_NAME_LENGTH = 128;
+/// Maximum length of the manufacturer name
+static constexpr size_t MAX_MANUFACTURER_NAME_LENGTH = 128;
+/// Maximum length of the description
+static constexpr size_t MAX_DESCRIPTION_LENGTH = 128;
+
+EndpointResources::EndpointResources() : m_isValid{true} {
+}
+
+bool EndpointResources::Label::operator==(const EndpointResources::Label& rhs) const {
+    return value == rhs.value && locale.valueOr("") == rhs.locale.valueOr("");
+}
+
+EndpointResources& EndpointResources::addFriendlyNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+
+    if (std::find(
+            m_friendlyNames.begin(),
+            m_friendlyNames.end(),
+            EndpointResources::Label(
+                    {Label::LabelType::ASSET, assetId, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>()})) != m_friendlyNames.end()) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "duplicateAssetId").sensitive("assetId", assetId));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_friendlyNames.push_back({Label::LabelType::ASSET, assetId, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>()});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addFriendlyNameWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+        if (text.length() == 0 || text.length() > MAX_FRIENDLY_NAME_LENGTH) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidText"));
+            m_isValid = false;
+            return *this;
+        }
+        if (locale.empty()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidLocale"));
+            m_isValid = false;
+            return *this;
+        }
+        if (std::find(
+                m_friendlyNames.begin(),
+                m_friendlyNames.end(),
+                Label({Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)})) !=
+                m_friendlyNames.end()) {
+            ACSDK_WARN(LX("addFriendlyNameWithTextFailed")
+                                .d("reason", "duplicateText")
+                                .sensitive("text", text)
+                                .sensitive("locale", locale));
+            return *this;
+        }
+
+        m_friendlyNames.push_back({Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::ASSET, assetId, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>()};
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_MANUFACTURER_NAME_LENGTH) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)};
+    return *this;
+};
+
+
+EndpointResources& EndpointResources::addDescriptionWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::ASSET, assetId, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>()};
+    return *this;
+};
+
+EndpointResources& EndpointResources::addDescriptionWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_DESCRIPTION_LENGTH) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)};
+    return *this;
+};
+
+bool EndpointResources::isValid() const {
+    return m_isValid && m_friendlyNames.size() > 0 && m_description.value.length() > 0
+                     && m_manufacturerName.value.length() > 0;
+};
+
+std::string EndpointResources::build() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return "";
+    }
+    json::JsonGenerator jsonGenerator;
+    std::vector<std::string> friendlyNames;
+    for (auto &friendlyName : m_friendlyNames){
+        friendlyNames.push_back(friendlyName.toJson());
+    }
+    jsonGenerator.addMembersArray("friendlyNames", friendlyNames);
+    jsonGenerator.addRawJsonMember("manufacturerName", m_manufacturerName.toJson());
+    jsonGenerator.addRawJsonMember("description", m_description.toJson());
+    return jsonGenerator.toString();
+};
+
+std::string EndpointResources::Label::toJson() const {
+    json::JsonGenerator scopeGenerator;
+    if (type == Label::LabelType::TEXT) {
+        scopeGenerator.addMember("@type", "text");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("text", value);
+        scopeGenerator.addMember("locale", locale.value());
+    } else if (type == Label::LabelType::ASSET) {
+        scopeGenerator.addMember("@type", "asset");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("assetId", value);
+    } else{
+        return "{}";
+    }
+    return scopeGenerator.toString();
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/src/MessageRequest.cpp b/AVSCommon/AVS/src/MessageRequest.cpp
index 6f3efbb6..028cb557 100644
--- a/AVSCommon/AVS/src/MessageRequest.cpp
+++ b/AVSCommon/AVS/src/MessageRequest.cpp
@@ -89,6 +89,16 @@ std::shared_ptr<MessageRequest::NamedReader> MessageRequest::getAttachmentReader
     return m_readers[index];
 }
 
+void MessageRequest::responseStatusReceived(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status) {
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        observer->onResponseStatusReceived(status);
+    }
+}
+
 void MessageRequest::sendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status) {
     std::unique_lock<std::mutex> lock{m_observerMutex};
     auto observers = m_observers;
diff --git a/AVSCommon/AVS/test/CapabilityResourcesTest.cpp b/AVSCommon/AVS/test/CapabilityResourcesTest.cpp
index 7c836170..10541c84 100644
--- a/AVSCommon/AVS/test/CapabilityResourcesTest.cpp
+++ b/AVSCommon/AVS/test/CapabilityResourcesTest.cpp
@@ -39,6 +39,12 @@ static std::string expectedFriendlyNamesJson =
     R"({"@type":"text","value":{"text":"air conditioner","locale":"en-US"}},)"
     R"({"@type":"asset","value":{"assetId":"Alexa.Setting.Temperature"}}])"
     R"(})";
+/// The expected friendly names json with a single value.
+static std::string expectedSimpleFriendlyNameJson =
+    R"({)"
+    R"("friendlyNames":[)"
+    R"({"@type":"text","value":{"text":"fan","locale":"en-US"}}])"
+    R"(})";
 
 /**
  * The test harness for @c CapabilityResources.
@@ -100,14 +106,16 @@ TEST_F(CapabilityResourcesTest, test_addFriendlyNameWithEmptyLocale) {
 }
 
 /**
- * Test if the addFriendlyNameWithText method checks for duplicate entries.
+ * Test if the addFriendlyNameWithText method checks for duplicate entries. It should succeed but skip the duplicate.
  */
 TEST_F(CapabilityResourcesTest, test_addFriendlyNameWithDuplicateText) {
     CapabilityResources capabilityResources;
+
     ASSERT_TRUE(capabilityResources.addFriendlyNameWithText(FAN_FRIENDLY_NAME, TEST_LOCALE));
-    ASSERT_FALSE(capabilityResources.addFriendlyNameWithText(FAN_FRIENDLY_NAME, TEST_LOCALE));
-    ASSERT_FALSE(capabilityResources.isValid());
-    ASSERT_EQ(capabilityResources.toJson(), "{}");
+    ASSERT_TRUE(capabilityResources.isValid());
+    ASSERT_TRUE(capabilityResources.addFriendlyNameWithText(FAN_FRIENDLY_NAME, TEST_LOCALE));
+    ASSERT_TRUE(capabilityResources.isValid());
+    ASSERT_EQ(capabilityResources.toJson(), expectedSimpleFriendlyNameJson);
 }
 
 /**
diff --git a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
index 3d4ec15f..016e4606 100644
--- a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
+++ b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
@@ -227,19 +227,11 @@ TEST_F(DialogUXAggregatorTest, test_aipExpectingSpeechLeadsToListeningState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::EXPECTING);
 }
 
-/// Tests that the AIP busy state leads to the LISTENING state.
-TEST_F(DialogUXAggregatorTest, test_aipBusyLeadsToListeningState) {
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
-}
-
 /// Tests that the RequestProcessingStarted leads to the THINKING state.
 TEST_F(DialogUXAggregatorTest, test_requestProcessingStartedLeadsToThinkingState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
@@ -255,6 +247,7 @@ TEST_F(DialogUXAggregatorTest, test_listeningGoesToIdleAfterTimeout) {
 
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
+    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
@@ -269,7 +262,7 @@ TEST_F(DialogUXAggregatorTest, test_thinkingGoesToIdleAfterTimeout) {
     anotherAggregator->addObserver(m_anotherTestObserver);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     anotherAggregator->onRequestProcessingStarted();
@@ -282,30 +275,30 @@ TEST_F(DialogUXAggregatorTest, test_thinkingGoesToIdleAfterTimeout) {
 TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveGoesToIdleAfterLongTimeout) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
 }
 
 /**
- * Tests that the LISTENING state goes to SPEAKING but not IDLE after both a message is received and a SpeechSynthesizer
- * speak state is received.
+ * Tests that the LISTENING state goes to SPEAKING but not IDLE after both RequestProcessingStarted and
+ * RequestProcessingCompleted are received followed by SpeechSynthesizer PLAYING.
  */
-TEST_F(DialogUXAggregatorTest, test_listeningThenReceiveThenSpeakGoesToSpeakButNotIdle) {
+TEST_F(DialogUXAggregatorTest, test_listeningThenRequestProcessingCompletedThenSpeakGoesToSpeakButNotIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
@@ -322,19 +315,18 @@ TEST_F(DialogUXAggregatorTest, test_listeningThenReceiveThenSpeakGoesToSpeakButN
 TEST_F(DialogUXAggregatorTest, test_speakingAndRecognizingFinishedGoesToIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
         TEST_SOURCE_ID,
         m_testMediaPlayerState,
         m_testAudioAnalyzerState);
-
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
     m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::IDLE);
@@ -352,7 +344,7 @@ TEST_F(DialogUXAggregatorTest, test_nonIdleObservantsPreventsIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
     // AIP is active, SS is not. Expected: non idle
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
         TEST_SOURCE_ID,
@@ -390,12 +382,12 @@ TEST_F(DialogUXAggregatorTest, test_nonIdleObservantsPreventsIdle) {
 TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
@@ -414,13 +406,13 @@ TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately
     assertNoStateChange(m_testObserver);
 }
 
-/// Tests that a simple message receive does nothing.
+/// Test that requestProcessingCompleted while SPEAKING does nothing.
 TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingStarted();
 
-    assertNoStateChange(m_testObserver);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
@@ -430,7 +422,7 @@ TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
 
     assertNoStateChange(m_testObserver);
 }
@@ -440,12 +432,12 @@ TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
 TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveRemainsInThinkingIfSpeechSynthesizerReportsGainingFocus) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS,
@@ -454,8 +446,6 @@ TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveRemainsInThinkingIfSpeech
         m_testAudioAnalyzerState);
 
     // Make sure after SpeechSynthesizer reports GAINING_FOCUS, that it would stay in THINKING state
-    m_aggregator->receive("", "");
-
     assertNoStateChange(m_testObserver, TRANSITION_TIMEOUT);
 }
 
@@ -465,14 +455,14 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
+    m_aggregator->onRequestProcessingCompleted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
@@ -497,20 +487,18 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
     assertNoStateChange(m_testObserver);
 }
 
-/// Test that if receive() happens before RequestProcessingCompleted directive is handled, we exit THINKING mode.
+/// Test that if RequestProcessingCompleted directive is handled, we exit THINKING mode.
 TEST_F(DialogUXAggregatorTest, test_receiveThenRPCTransitionsOutOfThinking) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->receive("", "");
-    m_aggregator->receive("", "");
-
     m_aggregator->onRequestProcessingStarted();
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
     m_aggregator->onRequestProcessingCompleted();
 
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
+
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 }
 
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index e69d7bce..031205f0 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -26,6 +26,7 @@ add_library(AVSCommon SHARED
     AVS/src/ComponentConfiguration.cpp
     AVS/src/DialogUXStateAggregator.cpp
     AVS/src/DirectiveRoutingRule.cpp
+    AVS/src/EndpointResources.cpp
     AVS/src/EventBuilder.cpp
     AVS/src/ExceptionEncounteredSender.cpp
     AVS/src/CapabilityResources.cpp
@@ -59,6 +60,8 @@ add_library(AVSCommon SHARED
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
index db20c72e..5c4e9895 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
@@ -41,17 +41,30 @@ public:
         NONE
     };
 
+    /// Information about the call to display on screen-based devices when the observer is notified of a call state change.
+    struct CallDisplayInfo {
+        /// The contact name to be displayed.
+        std::string displayName;
+        /// Information about the endpoint of the contact (work/mobile/home etc.).
+        std::string endpointLabel;
+        /// Contains name of callee for whom incoming call is intended. This field is not populated for Alexa/Skype calls currently.
+        std::string inboundCalleeName;
+        /// Textual description of exact call provider type (e.g. "Alexa Call", "Skype Call" etc.).
+        std::string callProviderType;
+    };
+
     /**
      * Destructor
      */
     virtual ~CallStateObserverInterface() = default;
 
     /**
-     * Allows the observer to react to a change in call state.
+     * Allows the observer to react to a change in call state with display info for the call.
      *
      * @param state The new CallState.
+     * @param displayInfo Information to be used for display on screen-based devices.
      */
-    virtual void onCallStateChange(CallState state) = 0;
+    virtual void onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) = 0;
 
     /**
      * Checks the state of the provided call state to determine if a call is in an "active" state
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
index 04c5935c..3e1cc35c 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
@@ -97,6 +97,10 @@ public:
      */
     virtual std::string getDialogRequestId() = 0;
 
+    virtual void setIsDialogRequestOnline(bool isOnline) = 0;
+
+    virtual bool isDialogRequestOnline() = 0;
+
     /**
      * Sequence the handling of an @c AVSDirective.  The actual handling is done by whichever @c DirectiveHandler
      * is associated with the most specific routing rule.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
index d22977fa..5af7c2b8 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
@@ -19,10 +19,12 @@
 #include <memory>
 #include <string>
 
+#include "AVSCommon/AVS/EndpointResources.h"
 #include "AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h"
 #include "AVSCommon/SDKInterfaces/DirectiveHandlerInterface.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesBuilderInterface.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesRegistrarInterface.h"
+#include "AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointInterface.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerInterface.h"
@@ -136,18 +138,32 @@ public:
      * @note This value can contain up to 128 characters.
      * @note The builder will fail if the manufacturer name param is invalid.
      *
-     * @param description The manufacturer name of the device representing the endpoint.
+     * @param manufacturerName The manufacturer name of the device representing the endpoint.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withManufacturerName(const std::string& manufacturerName) = 0;
 
+    /**
+     * Configures builder to use endpointResources representing the endpoint.
+     *
+     * @note EndpointResources contains friendlyNames, manufacturer name and description.
+     * @note Use either withFriendlyName, withDescription, withManufacturerName to build or withEndpointResources
+     * to build. 
+     * @note The builder will fail if the endpointResources param is invalid.
+     *
+     * @param endpointResources The endpointResources of the device representing the endpoint.
+     * @return This builder which can be used to nest configuration function calls.
+     */
+    virtual EndpointBuilderInterface& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) = 0;
+
     /**
      * Configures builder to use the following display categories.
      *
      * @note This will override any previous display categories configuration.
      * @note The builder will fail if the displayCategories param is invalid.
      *
-     * @param description The display category the device belongs to.
+     * @param displayCategories The display category the device belongs to.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withDisplayCategory(const std::vector<std::string>& displayCategories) = 0;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h
index af49c876..3dccb1d1 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h
@@ -85,8 +85,17 @@ public:
      */
     virtual ~MessageRequestObserverInterface() = default;
 
+    /**
+     * Called when the Response code is received.
+     *
+     * @param status The status of the response that was received.
+     */
+    virtual void onResponseStatusReceived(MessageRequestObserverInterface::Status status){};
+
     /*
      * Called when a message request has been processed by AVS.
+     *
+     * @param status The status of the response that was received.
      */
     virtual void onSendCompleted(MessageRequestObserverInterface::Status status) = 0;
 
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
new file mode 100644
index 00000000..80258547
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace messaging {
+
+/**
+ * This @c MessagingObserverInterface class is used to notify observers when a @c SendMessage,
+ * @c UpdateMessageStatus, or @c UploadConversations directive is received.
+ */
+class MessagingObserverInterface {
+public:
+    /**
+     * An enum representing the messaging endpoints.
+     */
+    enum class MessagingEndpoint {
+        /// Default messaging endpoint
+        DEFAULT
+    };
+
+    /**
+     * Destructor
+     */
+    virtual ~MessagingObserverInterface() = default;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.SendMessage directive
+     * is received. Once called, the client should send the message to the given recipients
+     * using the specified messaging endpoint.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint to send the message.
+     * @param jsonPayload The payload of the @c SendMessage directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "payload": {
+     *         "@type" : "text",
+     *         "text" : "{{STRING}}"
+     *     },
+     *     "recipients" : [
+     *         {
+     *             "address" : "{{STRING}}",
+     *             "addressType" : "PhoneNumberAddress"
+     *         }
+     *     ]
+     * }
+     * @endcode
+     *
+     */
+    virtual void sendMessage(const std::string& token, MessagingEndpoint endpoint, const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UploadConversations directive
+     * is received. Once called, the client should upload a conversations report using the specified
+     * filter in the JSON payload.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages are requested to be uploaded.
+     * @param jsonPayload The payload of the @c UploadConversations directive in structured JSON format. The only
+     * supported filter values are shown below.
+     * @code{.json}
+     * {
+     *     "filter" : {
+     *         "conversationFilter" : {
+     *             "@type" : "AllConversations",
+     *             "conversationIds" : [{{STRING}}]
+     *         },
+     *         "messageFilter" : {
+     *             "@type" : "UnreadMessages"
+     *         },
+     *         "maxMessageCount" : 40
+     *      }
+     * }
+     * @endcode
+     *
+     */
+    virtual void uploadConversations(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UpdateMessagesStatus directive
+     * is received. Once called, the client should update the specified messages with the given
+     * status.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages status need to be updated.
+     * @param jsonPayload The payload of the @c UpdateMessagesStatus directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "conversationId" : {{STRING}},
+     *     "statusMap" : {
+     *         "read" : [{{STRING}}],
+     *     }
+     * }
+     * @endcode
+     */
+    virtual void updateMessagesStatus(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+};
+
+}  // namespace messaging
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
\ No newline at end of file
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
index a1461998..f568cff3 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
@@ -37,6 +37,10 @@ public:
     inline std::string getDialogRequestId() {
         return m_dialogRequestId;
     };
+	
+	MOCK_METHOD0(isDialogRequestOnline, bool());
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+	
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
     MOCK_METHOD0(doShutdown, void());
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2ResponseFinishedStatus.h b/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2ResponseFinishedStatus.h
index 0b7e8ce5..14a14472 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2ResponseFinishedStatus.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2ResponseFinishedStatus.h
@@ -55,7 +55,7 @@ inline std::ostream& operator<<(std::ostream& stream, HTTP2ResponseFinishedStatu
         case HTTP2ResponseFinishedStatus::INTERNAL_ERROR:
             return stream << "INTERNAL_ERROR";
     }
-    return stream << "";
+    return stream << "Invalid(" << static_cast<int>(status) << ")";
 }
 
 }  // namespace http2
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index df111159..93b7653a 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -95,7 +95,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
@@ -277,6 +279,27 @@ public:
 
     CurlEasyHandleWrapperOptionsSettingAdapter& curlOptionsSetter();
 
+    /**
+     * Static function to set the network interface to be used for the curl
+     * connection.
+     *
+     * Network interface provided will be used in preference over the value
+     * in provided in config. Set emtpy string to reset to default.
+     *
+     * @note The network interace set shall applied only to newly instantiated
+     * @c CurlEasyHandleWrapper objects.
+     *
+     * @param value The interface name as defined in CURLOPT_INTERFACE.
+     */
+    static void setInterfaceName(const std::string& interfaceName);
+
+    /**
+     * Static function to get the network interface.
+     *
+     * @returns the current network interface, otherwise an empty string.
+     */
+    static std::string getInterfaceName();
+
 private:
     /**
      * Helper function for calling curl_easy_setopt and checking the result.
@@ -333,6 +356,9 @@ private:
     avsCommon::utils::logger::LogStringFormatter m_logFormatter;
 #endif
 
+    /// Initializes the @c m_interfaceName  from config.
+    static void initializeNetworkInterfaceName();
+
     /// The associated libcurl easy handle
     CURL* m_handle;
     /// A list of headers needed to be added at the HTTP level
@@ -345,7 +371,12 @@ private:
     curl_httppost* m_lastPost;
     /// Name for this handle.
     std::string m_id;
-
+    /// Synchronizes access to the @c m_interfaceName
+    static std::mutex m_interfaceNameMutex;
+    /// Indicates the initialization of @c m_interfaceName
+    static bool m_isInterfaceNameInitialized;
+    /// Interface name to be used for curl
+    static std::string m_interfaceName;
     /// If no id is provided by the user, we will generate it from this counter.
     static std::atomic<uint64_t> m_idGenerator;
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 00000000..bff624b6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 00000000..14459fa6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 00000000..f19dfd6e
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
new file mode 100644
index 00000000..68573f06
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP GET requests.
+class HttpGetInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpGetInterface() = default;
+
+    /**
+     * Perform an HTTP Get request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the GET to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the GET request.
+     */
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
index ec70c280..758a213d 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
@@ -39,7 +39,7 @@ public:
      *
      * @return The moniker for @c std::this_thread.
      */
-    static inline std::string getThisThreadMoniker();
+    static inline const char* getThisThreadMoniker();
 
     /**
      * Generate a unique moniker.
@@ -52,7 +52,8 @@ public:
      * Set the moniker for @c std::this_thread. This method should be called before @c getThisThreadMoniker() in order
      * to take effect.
      *
-     * @param moniker The moniker for @c std::this_thread.
+     * @param moniker The moniker for @c std::this_thread. The maximum length of the moniker is 15 characters. Any
+     * characters beyond the limit will be truncated.
      */
     static inline void setThisThreadMoniker(const std::string& moniker);
 
@@ -81,10 +82,10 @@ private:
     static const ThreadMoniker& getMonikerObjectFromMap(const std::string& moniker = std::string());
 
     /// The current thread's moniker.
-    std::string m_moniker;
+    char m_moniker[16];
 };
 
-std::string ThreadMoniker::getThisThreadMoniker() {
+const char* ThreadMoniker::getThisThreadMoniker() {
     return getMonikerObject().m_moniker;
 }
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
index 4d2c0e50..a19db92b 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
@@ -173,7 +173,11 @@ auto Executor::submitToFront(Task task, Args&&... args) -> std::future<decltype(
  */
 template <typename T>
 inline static void forwardPromise(std::shared_ptr<std::promise<T>> promise, std::future<T>* future) {
-    promise->set_value(future->get());
+    try {
+        promise->set_value(future->get());
+    } catch (...) {
+        promise->set_exception(std::current_exception());
+    }
 }
 
 /**
@@ -184,8 +188,12 @@ inline static void forwardPromise(std::shared_ptr<std::promise<T>> promise, std:
  */
 template <>
 inline void forwardPromise<void>(std::shared_ptr<std::promise<void>> promise, std::future<void>* future) {
-    future->get();
-    promise->set_value();
+    try {
+        future->get();
+        promise->set_value();
+    } catch (...) {
+        promise->set_exception(std::current_exception());
+    }
 }
 
 template <typename Task, typename... Args>
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index 46cc6d29..21a6af14 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -54,6 +54,12 @@ static const std::string LIBCURLUTILS_CONFIG_KEY = "libcurlUtils";
 static const std::string INTERFACE_CONFIG_KEY = "CURLOPT_INTERFACE";
 /// Counter used to geneate unique IDs.
 std::atomic<uint64_t> CurlEasyHandleWrapper::m_idGenerator{1};
+///  Interface used for the curl connection.
+std::string CurlEasyHandleWrapper::m_interfaceName{""};
+/// Indicates the initialization of @c m_interfaceName
+bool CurlEasyHandleWrapper::m_isInterfaceNameInitialized = false;
+/// Synchronizes access to the @c m_interfaceName
+std::mutex CurlEasyHandleWrapper::m_interfaceNameMutex;
 
 #ifdef ACSDK_EMIT_CURL_LOGS
 /// Key under 'acl' configuration node for path/prefix of per-stream log file names.
@@ -243,6 +249,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
@@ -252,7 +261,7 @@ bool CurlEasyHandleWrapper::setTransferTimeout(const long timeoutSeconds) {
 }
 
 bool CurlEasyHandleWrapper::setPostData(const std::string& data) {
-    return setopt(CURLOPT_POSTFIELDS, data.c_str());
+    return setopt(CURLOPT_POSTFIELDS, data.c_str()) && setopt(CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t) data.size());
 }
 
 bool CurlEasyHandleWrapper::setConnectionTimeout(const std::chrono::seconds timeoutSeconds) {
@@ -323,10 +332,14 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
             break;
         }
 
-        auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
-        std::string interfaceName;
-        if (config.getString(INTERFACE_CONFIG_KEY, &interfaceName) &&
-            !setopt(CURLOPT_INTERFACE, interfaceName.c_str())) {
+        {
+            std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+            if (!m_isInterfaceNameInitialized) {
+                initializeNetworkInterfaceName();
+            }
+        }
+
+        if (!m_interfaceName.empty() && !setopt(CURLOPT_INTERFACE, m_interfaceName.c_str())) {
             break;
         }
 
@@ -399,6 +412,41 @@ CurlEasyHandleWrapperOptionsSettingAdapter& CurlEasyHandleWrapper::curlOptionsSe
     return m_curlOptionsSettingAdapter;
 }
 
+void CurlEasyHandleWrapper::setInterfaceName(const std::string& interfaceName) {
+    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+    ACSDK_DEBUG(LX("setInterfaceName").d("interfaceName", interfaceName));
+
+    if (interfaceName.empty()) {
+        m_interfaceName = interfaceName;
+        // Reset to default value from config, if provided.
+        initializeNetworkInterfaceName();
+        return;
+    }
+    m_interfaceName = interfaceName;
+}
+
+std::string CurlEasyHandleWrapper::getInterfaceName() {
+    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+    if (!m_isInterfaceNameInitialized) {
+        initializeNetworkInterfaceName();
+    }
+    return m_interfaceName;
+}
+
+void CurlEasyHandleWrapper::initializeNetworkInterfaceName() {
+    auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
+    std::string interfaceNameFromConfig;
+    config.getString(INTERFACE_CONFIG_KEY, &interfaceNameFromConfig, "");
+
+    if (m_interfaceName.empty() && !interfaceNameFromConfig.empty()) {
+        // Update the value from config, so that getInterfaceName always
+        // return the current value.
+        m_interfaceName = interfaceNameFromConfig;
+    }
+    m_isInterfaceNameInitialized = true;
+    ACSDK_DEBUG(LX("initializeNetworkInterfaceName").d("m_interfaceName", m_interfaceName));
+}
+
 #ifdef ACSDK_EMIT_CURL_LOGS
 void CurlEasyHandleWrapper::initStreamLog() {
     std::string streamLogPrefix;
@@ -464,7 +512,7 @@ int CurlEasyHandleWrapper::debugFunction(CURL* handle, curl_infotype type, char*
         (*stream->m_streamLog) << logFormatter.format(
                                       logger::Level::INFO,
                                       std::chrono::system_clock::now(),
-                                      logger::ThreadMoniker::getThisThreadMoniker().c_str(),
+                                      logger::ThreadMoniker::getThisThreadMoniker(),
                                       curlInfoTypeToString(type))
                                << std::endl;
         if (CURLINFO_TEXT == type) {
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 00000000..129fca85
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 00000000..10e6836a
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Logger/Logger.cpp b/AVSCommon/Utils/src/Logger/Logger.cpp
index 3809d28a..d828e54d 100644
--- a/AVSCommon/Utils/src/Logger/Logger.cpp
+++ b/AVSCommon/Utils/src/Logger/Logger.cpp
@@ -36,7 +36,7 @@ Logger::Logger(Level level) : m_level{level} {
 
 void Logger::log(Level level, const LogEntry& entry) {
     if (shouldLog(level)) {
-        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker().c_str(), entry.c_str());
+        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker(), entry.c_str());
     }
 }
 
diff --git a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
index 363ae08b..98e2ac93 100644
--- a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
+++ b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
@@ -14,6 +14,7 @@
  */
 
 #include <atomic>
+#include <cstring>
 #include <iomanip>
 #include <mutex>
 #include <sstream>
@@ -30,7 +31,9 @@ namespace logger {
 /// Counter to generate (small) unique thread monikers.
 static std::atomic<int> g_nextThreadMoniker(1);
 
-ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{moniker.empty() ? generateMoniker() : moniker} {
+ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{} {
+    auto& m = moniker.empty() ? generateMoniker() : moniker;
+    std::strncpy(m_moniker, m.c_str(), sizeof(m_moniker) - 1);
 }
 
 std::string ThreadMoniker::generateMoniker() {
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
index e0e5fc2c..426cce1b 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
@@ -654,14 +654,10 @@ bool DefaultClient::initialize(
         m_connectionManager->addConnectionStatusObserver(observer);
     }
 
-    m_connectionManager->addMessageObserver(m_dialogUXStateAggregator);
-
     for (auto observer : alexaDialogStateObservers) {
         m_dialogUXStateAggregator->addObserver(observer);
     }
 
-    m_connectionManager->addMessageObserver(m_dialogUXStateAggregator);
-
     /*
      * Creating the Directive Sequencer - This is the component that deals with
      * the sequencing and ordering of
@@ -692,7 +688,7 @@ bool DefaultClient::initialize(
      * operation such as login and logout
      */
     m_registrationManager = std::make_shared<registrationManager::RegistrationManager>(
-        m_directiveSequencer, m_connectionManager, customerDataManager);
+        m_directiveSequencer, m_connectionManager, customerDataManager, metricRecorder);
 
     // Create endpoint related objects.
     m_capabilitiesDelegate->setMessageSender(m_connectionManager);
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
index 7368faf1..c3b43e84 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
@@ -317,6 +317,9 @@ private:
     /// A struct containing the in-flight and pending endpoints for Discovery.addOrUpdateReport event.
     InProcessEndpointsToConfigMapStruct m_addOrUpdateEndpoints;
 
+    /// A list that preserves the endpointId order.
+    std::vector<std::string> m_endpointsOrderList;
+
     /// A struct containing the in-flight and pending endpoints Discovery.deleteReport event.
     InProcessEndpointsToConfigMapStruct m_deleteEndpoints;
 
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
index c391f127..524e3131 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
@@ -50,12 +50,15 @@ public:
      * @param deleteReportEndpoints The map of endpoints for which the @c Discovery.DeleteReport event will be sent.
      * @param authDelegate The auth delegate instance to request the auth token from to be sent in the @c Discovery
      * events.
+     * @param endpointOrderList A list of endpointIds in registration order, used to preserve the order in @c Discovery
+     * events.
      * @return a new instance of the @c DiscoveryEventSender.
      */
     static std::shared_ptr<DiscoveryEventSender> create(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate);
+        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Destructor.
@@ -89,11 +92,14 @@ private:
      * @param deleteReportEndpoints The map of endpoints for which the @c Discovery.DeleteReport event will be sent.
      * @param authDelegate The auth delegate instance to request the auth token from to be sent in the @c Discovery
      * events.
+     * @param endpointOrderList A list of endpointIds in registration order, used to preserve the order in @c Discovery
+     * events.
      */
     DiscoveryEventSender(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate);
+        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Sends the discovery event while taking into account retries.
@@ -189,6 +195,9 @@ private:
     /// Auth delegate used to get the access token
     std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> m_authDelegate;
 
+    /// The endpoint order list
+    std::vector<std::string> m_endpointsOrderList;
+
     /// The authDelegate's auth status.
     AuthObserverInterface::State m_currentAuthState;
 
diff --git a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
index 6e8e726c..c186cd87 100644
--- a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
+++ b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
@@ -302,6 +302,7 @@ bool CapabilitiesDelegate::addOrUpdateEndpoint(
         }
 
         m_addOrUpdateEndpoints.pending.insert(std::make_pair(endpointId, endpointConfigJson));
+        m_endpointsOrderList.push_back(endpointId);
     }
 
     if (!m_currentDiscoveryEventSender) {
@@ -465,6 +466,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
     /// The endpoints that need to be sent to AVS.
     std::unordered_map<std::string, std::string> addOrUpdateEndpointsToSend;
     std::unordered_map<std::string, std::string> deleteEndpointsToSend;
+    std::vector<std::string> endpointOrderList;
     {
         std::lock_guard<std::mutex> lock{m_endpointsMutex};
 
@@ -512,6 +514,8 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
         m_deleteEndpoints.inFlight = m_deleteEndpoints.pending;
         deleteEndpointsToSend = m_deleteEndpoints.inFlight;
         m_deleteEndpoints.pending.clear();
+
+        endpointOrderList = m_endpointsOrderList;
     }
 
     /// Sometimes pending add/update endpoints do not need to be sent to AVS as they are already stored
@@ -538,7 +542,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
                      .d("num endpoints to delete", deleteEndpointsToSend.size()));
 
     std::shared_ptr<DiscoveryEventSenderInterface> newEventSender =
-        DiscoveryEventSender::create(addOrUpdateEndpointsToSend, deleteEndpointsToSend, m_authDelegate);
+        DiscoveryEventSender::create(addOrUpdateEndpointsToSend, deleteEndpointsToSend, m_authDelegate, endpointOrderList);
     if (!newEventSender) {
         ACSDK_ERROR(LX("createPostConnectOperationFailed").m("Could not create DiscoveryEventSender."));
         return nullptr;
diff --git a/CapabilitiesDelegate/src/DiscoveryEventSender.cpp b/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
index f957b418..34fb39be 100644
--- a/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
+++ b/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
@@ -60,14 +60,15 @@ static const auto ASYNC_RESPONSE_TIMEOUT = std::chrono::seconds(2);
 std::shared_ptr<DiscoveryEventSender> DiscoveryEventSender::create(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-    const std::shared_ptr<AuthDelegateInterface>& authDelegate) {
+    const std::shared_ptr<AuthDelegateInterface>& authDelegate,
+    const std::vector<std::string>& endpointOrderList) {
     if (addOrUpdateReportEndpoints.empty() && deleteReportEndpoints.empty()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "endpoint map empty"));
     } else if (!authDelegate) {
         ACSDK_ERROR(LX("createFailed").d("reason", "invalid auth delegate"));
     } else {
         auto instance = std::shared_ptr<DiscoveryEventSender>(
-            new DiscoveryEventSender(addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate));
+            new DiscoveryEventSender(addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate, endpointOrderList));
 
         return instance;
     }
@@ -77,10 +78,12 @@ std::shared_ptr<DiscoveryEventSender> DiscoveryEventSender::create(
 DiscoveryEventSender::DiscoveryEventSender(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-    const std::shared_ptr<AuthDelegateInterface>& authDelegate) :
+    const std::shared_ptr<AuthDelegateInterface>& authDelegate,
+    const std::vector<std::string>& endpointOrderList) :
         m_addOrUpdateReportEndpoints{addOrUpdateReportEndpoints},
         m_deleteReportEndpoints{deleteReportEndpoints},
         m_authDelegate{authDelegate},
+        m_endpointsOrderList{endpointOrderList},
         m_currentAuthState{AuthObserverInterface::State::UNINITIALIZED},
         m_isStopping{false},
         m_isSendDiscoveryEventsInvoked{false} {
@@ -313,8 +316,17 @@ bool DiscoveryEventSender::sendAddOrUpdateReportEvents(
     }
     /// Collect all endpoint configurations
     std::vector<std::string> allEndpointConfigs;
-    for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
-        allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+    if (!m_endpointsOrderList.empty()) {
+        /// Look into the endpoints map in the order of the m_endpointsOrderList
+        for (const auto& endpointId : m_endpointsOrderList) {
+            if (m_addOrUpdateReportEndpoints.find(endpointId) != m_addOrUpdateReportEndpoints.end()) {
+                allEndpointConfigs.push_back(m_addOrUpdateReportEndpoints[endpointId]);
+            }
+        }
+    } else {
+        for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
+            allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+        }
     }
 
     return sendDiscoveryEvents(allEndpointConfigs, messageSender, true);
diff --git a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
index 62c7dcdb..f07127ac 100644
--- a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
+++ b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
@@ -68,6 +68,8 @@ const static std::string FRIENDLY_NAME_KEY = "friendlyName";
 const static std::string DESCRIPTION_KEY = "description";
 /// Manufacturer name key
 const static std::string MANUFACTURER_NAME_KEY = "manufacturerName";
+/// EndpointResources ID key
+const static std::string ENDPOINTRESOURCES_KEY = "endpointResources";
 /// Display Categories key
 const static std::string DISPLAY_CATEGORIES_KEY = "displayCategories";
 /// Additional Attributes key
@@ -259,14 +261,18 @@ bool validateEndpointAttributes(const AVSDiscoveryEndpointAttributes& endpointAt
         return false;
     }
 
-    if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
-        return false;
-    }
+    if (!endpoints::isEndpointResourcesValid(endpointAttributes.endpointResources)) {
 
-    if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
-        return false;
+    // Validate the legacy fields if the endpointResources object is invalid.
+        if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
+            return false;
+        }
+
+        if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
+            return false;
+        }
     }
 
     if (endpointAttributes.displayCategories.empty()) {
@@ -299,9 +305,14 @@ std::string getEndpointConfigJson(
     JsonGenerator generator;
 
     generator.addMember(ENDPOINT_ID_KEY, endpointAttributes.endpointId);
-    generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
-    generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
-    generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    /// Endpoint Resources.
+    if (endpointAttributes.endpointResources.isValid()) {
+        generator.addRawJsonMember(ENDPOINTRESOURCES_KEY, endpointAttributes.endpointResources.build());
+    } else {
+        generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
+        generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
+        generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    }
     addSortedStringArray(generator, DISPLAY_CATEGORIES_KEY, endpointAttributes.displayCategories);
 
     /// Additional Attributes Object.
diff --git a/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h b/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
index 4f5fe55f..21d7ca47 100644
--- a/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
+++ b/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
@@ -255,6 +255,7 @@ public:
 
     /// @name MessageRequestObserverInterface Functions
     /// @{
+    void onResponseStatusReceived(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status) override;
     void onSendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status) override;
     void onExceptionReceived(const std::string& exceptionMessage) override;
     /// @}
@@ -469,6 +470,7 @@ private:
      * @param KWDMetadata Wake word engine metadata.
      * @param initiatedByWakeword Whether the Initiator was Wakeword; false by default.
      * @param falseWakewordDetection Whether false Wakeword detection was enabled; false by default.
+     * @param initiatorString - The @c Initiator string to be used to log a metric.
      * @return @c true if the Recognize Event was started successfully, else @c false.
      */
     bool executeRecognize(
@@ -480,7 +482,8 @@ private:
         const std::string& keyword = "",
         std::shared_ptr<const std::vector<char>> KWDMetadata = nullptr,
         bool initiatedByWakeword = false,
-        bool falseWakewordDetection = false);
+        bool falseWakewordDetection = false,
+        const std::string& initiatorString = "");
 
     /**
      * This function receives the full system context from @c ContextManager.  Context requests are initiated by
diff --git a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
index 4f9acc89..1d877a41 100644
--- a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
+++ b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
@@ -210,6 +210,13 @@ static const std::string STOP_CAPTURE_TO_END_OF_SPEECH_METRIC_NAME = "STOP_CAPTU
 static const std::string STOP_CAPTURE_TO_END_OF_SPEECH_ACTIVITY_NAME =
     METRIC_ACTIVITY_NAME_PREFIX_AIP + STOP_CAPTURE_TO_END_OF_SPEECH_METRIC_NAME;
 
+/// The recognize request initiator metric.
+static const std::string INITIATOR_PREFIX = "INITIATOR_";
+static const std::string INITIATOR_ACTIVITY_NAME_PREFIX = METRIC_ACTIVITY_NAME_PREFIX_AIP + INITIATOR_PREFIX;
+
+/// The default resolveKey used as a placeholder when only one encoding format is configured for @c AudioInputProcessor
+static const std::string DEFAULT_RESOLVE_KEY = "DEFAULT_RESOLVE_KEY";
+
 /// Preroll duration is a fixed 500ms.
 static const std::chrono::milliseconds PREROLL_DURATION = std::chrono::milliseconds(500);
 
@@ -451,6 +458,7 @@ std::future<bool> AudioInputProcessor::stopCapture() {
 }
 
 std::future<void> AudioInputProcessor::resetState() {
+    ACSDK_DEBUG0(LX(__func__));
     return m_executor.submit([this]() { executeResetState(); });
 }
 
@@ -751,7 +759,8 @@ bool AudioInputProcessor::executeRecognize(
 
     // If we will be enabling false wakeword detection, add preroll and build the initiator payload.
     json::JsonGenerator generator;
-    generator.addMember(TYPE_KEY, initiatorToString(initiator));
+    std::string initiatorString = initiatorToString(initiator);
+    generator.addMember(TYPE_KEY, initiatorString);
     generator.startObject(PAYLOAD_KEY);
     // If we will be enabling false wakeword detection, add preroll and build the initiator payload.
     if (falseWakewordDetection) {
@@ -782,7 +791,8 @@ bool AudioInputProcessor::executeRecognize(
         keyword,
         KWDMetadata,
         initiatedByWakeword,
-        falseWakewordDetection);
+        falseWakewordDetection,
+        initiatorString);
 }
 
 bool AudioInputProcessor::executeRecognize(
@@ -794,7 +804,8 @@ bool AudioInputProcessor::executeRecognize(
     const std::string& keyword,
     std::shared_ptr<const std::vector<char>> KWDMetadata,
     bool initiatedByWakeword,
-    bool falseWakewordDetection) {
+    bool falseWakewordDetection,
+    const std::string& initiatorString) {
     if (!provider.stream) {
         ACSDK_ERROR(LX("executeRecognizeFailed").d("reason", "nullAudioInputStream"));
         return false;
@@ -984,6 +995,17 @@ bool AudioInputProcessor::executeRecognize(
             .addDataPoint(DataPointCounterBuilder{}.setName(START_OF_UTTERANCE).increment(1).build()),
         m_preCachedDialogRequestId);
 
+    /// Submit initiator metric if available.
+    if (!initiatorString.empty()) {
+        submitMetric(
+            m_metricRecorder,
+            MetricEventBuilder{}
+                .setActivityName(INITIATOR_ACTIVITY_NAME_PREFIX + initiatorString)
+                .addDataPoint(
+                    DataPointCounterBuilder{}.setName(INITIATOR_PREFIX + initiatorString).increment(1).build()),
+            m_preCachedDialogRequestId);
+    }
+
     if (initiatedByWakeword) {
         auto duration = milliseconds((end - begin) * MILLISECONDS_PER_SECOND / provider.format.sampleRateHz);
 
@@ -1281,6 +1303,8 @@ bool AudioInputProcessor::executeExpectSpeechTimedOut() {
 }
 
 void AudioInputProcessor::executeOnDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
+    ACSDK_DEBUG0(LX(__func__).d("newState", newState));
+
     if (!m_initialDialogUXStateReceived) {
         // The initial dialog UX state change call comes from simply registering as an observer; it is not a deliberate
         // change to the dialog state which should interrupt a recognize event.
@@ -1342,6 +1366,17 @@ void AudioInputProcessor::sendRequestNow() {
     }
 }
 
+void AudioInputProcessor::onResponseStatusReceived(
+    avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status) {
+    ACSDK_DEBUG(LX("onResponseStatusReceived").d("status", status));
+    if (status == MessageRequestObserverInterface::Status::SUCCESS ||
+        status == MessageRequestObserverInterface::Status::PENDING) {
+        stopCapture();
+    } else {
+        resetState();
+    }
+}
+
 void AudioInputProcessor::onExceptionReceived(const std::string& exceptionMessage) {
     ACSDK_ERROR(LX("onExceptionReceived").d("exception", exceptionMessage));
     resetState();
@@ -1349,16 +1384,6 @@ void AudioInputProcessor::onExceptionReceived(const std::string& exceptionMessag
 
 void AudioInputProcessor::onSendCompleted(MessageRequestObserverInterface::Status status) {
     ACSDK_DEBUG(LX("onSendCompleted").d("status", status));
-
-    if (status == MessageRequestObserverInterface::Status::SUCCESS ||
-        status == MessageRequestObserverInterface::Status::PENDING) {
-        // Stop listening from audio input source when the recognize event steam is closed.
-        ACSDK_DEBUG5(LX("stopCapture").d("reason", "streamClosed"));
-        stopCapture();
-
-        return;
-    }
-    ACSDK_DEBUG(LX("resetState").d("dueToStatus", status));
     resetState();
 }
 
diff --git a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
index 320cf19d..be70f3fb 100644
--- a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
+++ b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
@@ -616,7 +616,7 @@ TestDialogUXStateObserver::TestDialogUXStateObserver(
 
 void TestDialogUXStateObserver::onDialogUXStateChanged(DialogUXState newState) {
     if (DialogUXState::THINKING == newState) {
-        m_aggregator->receive("", "");
+        m_aggregator->onRequestProcessingCompleted();
     }
 }
 
@@ -654,8 +654,10 @@ protected:
     /// Enumerates the different points when to pass a stop capture directive to AIP via @c
     /// AudioInputProcessor::handleDirectiveImmediately())
     enum class StopCaptureDirectiveSchedule {
-        /// Pass a stop capture directive to AIP before the event stream is closed.
-        BEFORE_EVENT_STREAM_CLOSE,
+        /// Pass a stop capture directive to AIP before the response code to the Recognize request is receeived.
+        BEFORE_RESPONSE_STATUS_RECEIVED,
+        /// Pass a stop capture directive to AIP after the response ccode to the Recognize requet is received.
+        AFTER_RESPONSE_CODE_RECEIVED,
         /// Pass a stop capture directive after the event stream is closed.
         AFTER_EVENT_STREAM_CLOSE,
         /// Do not pass a stop capture directive.
@@ -829,21 +831,23 @@ protected:
      */
     bool testFocusChange(avsCommon::avs::FocusState state, avsCommon::avs::MixingBehavior behavior);
 
-    /**
-     * Performs a test to check the AIP correctly transitions to a state after getting notified that the recognize event
-     * stream has been closed and/or receiving a stop capture directive.
-     *
-     * @param eventStreamFinishedStatus The status of the recognize event stream when the stream closes.
-     * @param stopCaptureSchedule Specify the point when to pass a stop capture directive to AIP.
-     * @param expectedAIPFinalState The expected final state of the AIP.
-     * @param expectFocusReleased If true, it is expected that AIP will release the channel focus in the final state,
-     * and false otherwise.
-     */
-    void testAIPStateTransitionOnEventFinish(
-        avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status eventStreamFinishedStatus,
+     /**
+      * Performs a test to check the AIP correctly transitions to a state after getting notified of the
+      * response to the recognize event and/or receiving a stop capture directive.
+      *
+      * @param responseStatus The response status for the recognize request.
+      * @param stopCaptureSchedule Specify the point when to pass a stop capture directive to AIP.
+      * @param expectedAIPFinalState The expected final state of the AIP.
+      * @param expectFocusReleased If true, it is expected that AIP will release the channel focus in the final state,
+      * and false otherwise.
+      * @param closeRequest Whether onSendCompleted() should be called to simulate a stream close.
+      */
+    void testAIPStateTransitionOnEventResponse(
+        avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status responseStatus,
         StopCaptureDirectiveSchedule stopCaptureSchedule,
         AudioInputProcessorObserverInterface::State expectedAIPFinalState,
-        bool expectFocusReleased);
+        bool expectFocusReleased,
+        bool closeRequest = true);
 
     /// The metric recorder.
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
@@ -1651,11 +1655,12 @@ bool AudioInputProcessorTest::testFocusChange(
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
 }
 
-void AudioInputProcessorTest::testAIPStateTransitionOnEventFinish(
-    avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status eventStreamFinishedStatus,
+void AudioInputProcessorTest::testAIPStateTransitionOnEventResponse(
+    MessageRequestObserverInterface::Status responseStatus,
     StopCaptureDirectiveSchedule stopCaptureSchedule,
     AudioInputProcessorObserverInterface::State expectedAIPFinalState,
-    bool expectFocusReleased) {
+    bool expectFocusReleased,
+    bool closeRequest) {
     // Simulate tap to talk and start recognizing.
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
 
@@ -1671,11 +1676,22 @@ void AudioInputProcessorTest::testAIPStateTransitionOnEventFinish(
 
     auto avsDirective = createAVSDirective(STOP_CAPTURE, true);
 
-    if (StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE == stopCaptureSchedule) {
+    if (StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED == stopCaptureSchedule) {
+        m_audioInputProcessor->handleDirectiveImmediately(avsDirective);
+    }
+
+    if (MessageRequestObserverInterface::Status::TIMEDOUT != responseStatus &&
+        MessageRequestObserverInterface::Status::CANCELED != responseStatus) {
+        m_audioInputProcessor->onResponseStatusReceived(responseStatus);
+    }
+
+    if (StopCaptureDirectiveSchedule::AFTER_RESPONSE_CODE_RECEIVED == stopCaptureSchedule) {
         m_audioInputProcessor->handleDirectiveImmediately(avsDirective);
     }
 
-    m_audioInputProcessor->onSendCompleted(eventStreamFinishedStatus);
+    if (closeRequest) {
+        m_audioInputProcessor->onSendCompleted(responseStatus);
+    }
 
     if (StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE == stopCaptureSchedule) {
         m_audioInputProcessor->handleDirectiveImmediately(avsDirective);
@@ -2535,15 +2551,41 @@ TEST_F(AudioInputProcessorTest, test_recognizeInvalidWakeWord) {
         testRecognizeFails(*m_audioProvider, Initiator::WAKEWORD, begin, end, AudioInputProcessor::KEYWORD_TEXT_STOP));
 }
 
+/**
+ * This function verifies that @c AudioInputProcessor state will stop listening when the recognize event stream
+ * has received SUCCESS but not yet closed.
+ */
+TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessBeforeClose) {
+    testAIPStateTransitionOnEventResponse(
+        avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
+        StopCaptureDirectiveSchedule::NONE,
+        AudioInputProcessorObserverInterface::State::BUSY,
+        false,
+        false);
+}
+
 /**
  * This function verifies that @c AudioInputProcessor state will stop listening when the recognize event stream has been
  * successfully sent.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccess) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
         StopCaptureDirectiveSchedule::NONE,
-        AudioInputProcessorObserverInterface::State::BUSY,
+        AudioInputProcessorObserverInterface::State::IDLE,
+        true);
+}
+
+/**
+ * This function verifies that @c AudioInputProcessor state will stop listening when the recognize event stream
+ * has received SUCCESS_NO_CONTENT but the stream has not yet closed.
+ */
+TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentBeforeClose) {
+    testAIPStateTransitionOnEventResponse(
+        avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
+        StopCaptureDirectiveSchedule::NONE,
+        AudioInputProcessorObserverInterface::State::IDLE,
+        false,
         false);
 }
 
@@ -2552,7 +2594,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccess) {
  * successfully sent but received no HTTP/2 content.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContent) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2564,7 +2606,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContent) {
  * been sent due to connection to AVS has been severed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnected) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_CONNECTED,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2576,7 +2618,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnected) {
  * been sent due to AVS is not synchronized.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronized) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2588,7 +2630,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronized) {
  * been sent due to an internal error within ACL.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrror) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INTERNAL_ERROR,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2600,7 +2642,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrror) {
  * been sent due to an underlying protocol error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolError) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PROTOCOL_ERROR,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2612,7 +2654,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolError) {
  * been sent due to an internal error on the server which sends code 500.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalError) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2624,7 +2666,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalError) {
  * been sent due to server refusing the request.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefused) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::REFUSED,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2636,7 +2678,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefused) {
  * been sent due to server canceling it before the transmission completed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceled) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::CANCELED,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2648,7 +2690,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceled) {
  * been sent due to excessive load on the server.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottled) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::THROTTLED,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2660,7 +2702,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottled) {
  * been sent due to the access credentials provided to ACL were invalid.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuth) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INVALID_AUTH,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2672,7 +2714,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuth) {
  * been sent due to invalid request sent by the user.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequest) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::BAD_REQUEST,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2684,7 +2726,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequest) {
  * been sent due to unknown server error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerError) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR,
         StopCaptureDirectiveSchedule::NONE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2696,9 +2738,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerError) {
  * recognize event stream has been successfully sent.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccess) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::BUSY,
         false);
 }
@@ -2708,9 +2750,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccess) {
  * recognize event stream has been successfully sent but received no HTTP/2 content.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNoContent) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::BUSY,
         false);
 }
@@ -2720,9 +2762,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNoCon
  * recognize event stream has not been sent due to connection to AVS has been severed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNotConnected) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_CONNECTED,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2732,9 +2774,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNotCo
  * recognize event stream has not been sent due to AVS is not synchronized.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamNotSynchronized) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2744,9 +2786,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamNotSynchroni
  * recognize event stream has not been sent due to an internal error within ACL.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInternalrror) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INTERNAL_ERROR,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2756,9 +2798,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInternalrror
  * recognize event stream has not been sent due to an underlying protocol error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamProtocolError) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PROTOCOL_ERROR,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2768,9 +2810,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamProtocolErro
  * recognize event stream has not been sent due to an internal error on the server which sends code 500.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamServerInternalError) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2780,9 +2822,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamServerIntern
  * recognize event stream has not been sent due to server refusing the request.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamRefused) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::REFUSED,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2792,9 +2834,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamRefused) {
  * recognize event stream has not been sent due to server canceling it before the transmission completed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamCanceled) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::CANCELED,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2804,9 +2846,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamCanceled) {
  * recognize event stream has not been sent due to excessive load on the server.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamThrottled) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::THROTTLED,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2816,9 +2858,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamThrottled) {
  * recognize event stream has not been sent due to the access credentials provided to ACL were invalid.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInvalidAuth) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INVALID_AUTH,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2828,9 +2870,9 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInvalidAuth)
  * recognize event stream has not been sent due to invalid request sent by the user.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamBadRequest) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::BAD_REQUEST,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
@@ -2840,23 +2882,36 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamBadRequest)
  * recognize event stream has not been sent due to unknown server error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamUnknownServerError) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR,
-        StopCaptureDirectiveSchedule::BEFORE_EVENT_STREAM_CLOSE,
+        StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
         AudioInputProcessorObserverInterface::State::IDLE,
         true);
 }
 
+/**
+ * This function verifies that @c AudioInputProcessor state is correct after the recognize event stream has received
+ * SUCCESS but is not yet closed and a stop capture directive has been received.
+ */
+TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirectiveBeforeClose) {
+    testAIPStateTransitionOnEventResponse(
+        avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
+        StopCaptureDirectiveSchedule::AFTER_RESPONSE_CODE_RECEIVED,
+        AudioInputProcessorObserverInterface::State::BUSY,
+        false,
+        false);
+}
+
 /**
  * This function verifies that @c AudioInputProcessor state is correct after the recognize event stream has been
  * successfully sent and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
-        AudioInputProcessorObserverInterface::State::BUSY,
-        false);
+        AudioInputProcessorObserverInterface::State::IDLE,
+        true);
 }
 
 /**
@@ -2864,7 +2919,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirective) {
  * successfully sent but received no HTTP/2 content and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2876,7 +2931,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentAndDirec
  * been sent due to connection to AVS has been severed and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnectedAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_CONNECTED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2888,7 +2943,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnectedAndDi
  * been sent due to AVS is not synchronized and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronizedAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2900,7 +2955,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronizedAndDirect
  * been sent due to an internal error within ACL and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrrorAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INTERNAL_ERROR,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2912,7 +2967,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrrorAndDirective
  * been sent due to an underlying protocol error and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolErrorAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PROTOCOL_ERROR,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2924,7 +2979,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolErrorAndDirectiv
  * been sent due to an internal error on the server which sends code 500  and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalErrorAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2936,7 +2991,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalErrorAndDi
  * been sent due to server refusing the request and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefusedAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::REFUSED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2948,7 +3003,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefusedAndDirective) {
  * been sent due to server canceling it before the transmission completed and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceledAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::CANCELED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2960,7 +3015,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceledAndDirective) {
  * been sent due to excessive load on the server and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottledAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::THROTTLED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2972,7 +3027,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottledAndDirective) {
  * been sent due to the access credentials provided to ACL were invalid and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuthAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INVALID_AUTH,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2984,7 +3039,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuthAndDirective)
  * been sent due to invalid request sent by the user and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequestAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::BAD_REQUEST,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
@@ -2996,7 +3051,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequestAndDirective)
  * been sent due to unknown server error and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerErrorAndDirective) {
-    testAIPStateTransitionOnEventFinish(
+    testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
         AudioInputProcessorObserverInterface::State::IDLE,
diff --git a/CapabilityAgents/CMakeLists.txt b/CapabilityAgents/CMakeLists.txt
index 3e3e2c4a..b8ab0697 100644
--- a/CapabilityAgents/CMakeLists.txt
+++ b/CapabilityAgents/CMakeLists.txt
@@ -9,12 +9,14 @@ set(CAPABILITY_AGENTS
         "ApiGateway"
         "Equalizer"
         "InteractionModel"
+        "Messaging"
         "Notifications"
         "PlaybackController"
         "SoftwareComponentReporter"
         "SpeakerManager"
         "SpeechSynthesizer"
         "System"
+        "DeviceSetup"
         "TemplateRuntime")
 
 if (COMMS)
diff --git a/CapabilityAgents/DeviceSetup/Android.mk b/CapabilityAgents/DeviceSetup/Android.mk
new file mode 100644
index 00000000..0e65e225
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/Android.mk
@@ -0,0 +1,2 @@
+LOCAL_PATH:= $(call my-dir)
+include $(call all-makefiles-under, $(LOCAL_PATH))
diff --git a/CapabilityAgents/DeviceSetup/CMakeLists.txt b/CapabilityAgents/DeviceSetup/CMakeLists.txt
new file mode 100644
index 00000000..5bdc2f07
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/CMakeLists.txt
@@ -0,0 +1,7 @@
+cmake_minimum_required(VERSION 3.0)
+project(DeviceSetup LANGUAGES CXX)
+
+include(${AVS_CORE}/build/BuildDefaults.cmake)
+
+add_subdirectory("interface")
+add_subdirectory("capabilityagent")
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/Android.mk b/CapabilityAgents/DeviceSetup/capabilityagent/Android.mk
new file mode 100644
index 00000000..af8071d5
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/Android.mk
@@ -0,0 +1,42 @@
+LOCAL_PATH:= $(call my-dir)
+
+#########################
+# Declare common variables
+
+DeviceSetup_SRC_FILES := \
+    $(call all-cpp-files-under,src/)
+DeviceSetup_TEST_FILES := \
+    $(call all-cpp-files-under,test/)
+DeviceSetup_C_INCLUDES := $(LOCAL_PATH)/include
+DeviceSetup_CFLAGS := \
+    $(AVS_COMMON_CFLAGS) \
+    -DACSDK_LOG_MODULE
+
+#########################
+# Build the shared library
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(DeviceSetup_SRC_FILES)
+LOCAL_C_INCLUDES := $(DeviceSetup_C_INCLUDES)
+LOCAL_CFLAGS := $(DeviceSetup_CFLAGS)
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(DeviceSetup_C_INCLUDES)
+
+LOCAL_MODULE := libDeviceSetupCA
+LOCAL_SHARED_LIBRARIES := libAVSCommon libDeviceSetupInterfaces
+
+include $(BUILD_SHARED_LIBRARY)
+
+#########################
+# Build the shared host library
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(DeviceSetup_SRC_FILES)
+LOCAL_C_INCLUDES := $(DeviceSetup_C_INCLUDES)
+LOCAL_CFLAGS := $(DeviceSetup_CFLAGS)
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(DeviceSetup_C_INCLUDES)
+
+LOCAL_MODULE := libDeviceSetupCA-host
+LOCAL_SHARED_LIBRARIES := libAVSCommon-host libDeviceSetupInterfaces-host
+LOCAL_MULTILIB := 64
+
+include $(BUILD_HOST_SHARED_LIBRARY)
\ No newline at end of file
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/CMakeLists.txt b/CapabilityAgents/DeviceSetup/capabilityagent/CMakeLists.txt
new file mode 100644
index 00000000..c83e07c8
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/CMakeLists.txt
@@ -0,0 +1,7 @@
+cmake_minimum_required(VERSION 3.1)
+project(DeviceSetupCA LANGUAGES CXX)
+
+include(${AVS_CORE}/build/BuildDefaults.cmake)
+
+add_subdirectory("src")
+add_subdirectory("test")
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetup.h b/CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetup.h
new file mode 100644
index 00000000..0a84c1e3
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetup.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_CAPABILITYAGENT_INCLUDE_DEVICESETUP_DEVICESETUP_H_
+#define ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_CAPABILITYAGENT_INCLUDE_DEVICESETUP_DEVICESETUP_H_
+
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <DeviceSetup/Interfaces/DeviceSetupInterface.h>
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace deviceSetup {
+
+/**
+ * The @c DeviceSetup capability agent. The purpose of this CA is to noitfy the cloud when DeviceSetup has completed.
+ * DeviceSetupInterface::sendDeviceSetupComplete will return a future.
+ */
+class DeviceSetup
+        : public interfaces::deviceSetup::DeviceSetupInterface
+        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public std::enable_shared_from_this<DeviceSetup> {
+public:
+    /**
+     * Create an instance of the DeviceSetup CA.
+     *
+     * @param messageSender A @c MessageSenderInterface to send messages to AVS.
+     * @return A ptr to the DeviceSetup CA if successful or nullptr otherwise.
+     */
+    static std::shared_ptr<DeviceSetup> create(
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /// @name CapabilityConfigurationInterface Functions
+    /// @{
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    /// @}
+
+    /// @name DeviceSetupInterface Functions
+    /// @{
+    std::future<bool> sendDeviceSetupComplete(interfaces::deviceSetup::AssistedSetup assistedSetup) override;
+    /// @}
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param messageSender A @c MessageSenderInterface to send messages to AVS.
+     */
+    DeviceSetup(std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /// The @c MessageSenderInterface used to send event messages.
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+};
+
+}  // namespace deviceSetup
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_CAPABILITYAGENT_INCLUDE_DEVICESETUP_DEVICESETUP_H_
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetupMessageRequest.h b/CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetupMessageRequest.h
new file mode 100644
index 00000000..4e4850d0
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/include/DeviceSetup/DeviceSetupMessageRequest.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_CAPABILITYAGENT_INCLUDE_DEVICESETUP_DEVICESETUPMESSAGEREQUEST_H_
+#define ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_CAPABILITYAGENT_INCLUDE_DEVICESETUP_DEVICESETUPMESSAGEREQUEST_H_
+
+#include <atomic>
+#include <future>
+#include <string>
+
+#include <AVSCommon/AVS/MessageRequest.h>
+#include <AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h>
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace deviceSetup {
+
+/**
+ * This class extends @c MessageRequest to fulfill a promise upon sending completion.
+ * Currently @c MessageRequestObserverInterface callbacks do not return an identifier. This makes it difficult
+ * to associate callbacks when multiple requests are sent.
+ * The future allows multiple messages to be sent, and their returns to be differentiated.
+ */
+class DeviceSetupMessageRequest : public avsCommon::avs::MessageRequest {
+public:
+    /**
+     * @copyDoc avsCommon::avs::MessageRequest()
+     *
+     * Construct a @c MessageRequest that will fulfill the promise upon completion.
+     *
+     * @param jsonContent The JSON content to be sent to AVS.
+     * @param messageCompletePromise The promise to set with the results.
+     */
+    DeviceSetupMessageRequest(const std::string& jsonContent, std::promise<bool> messageCompletePromise);
+
+    /// @note We do not override exceptionEncountered because sendCompleted is still expected on server exceptions.
+
+    /// @name MessageRequest functions.
+    /// @{
+    void sendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status status) override;
+    /// @}
+
+private:
+    /// Guard that we only set the promise once.
+    std::atomic<bool> m_isPromiseSet;
+
+    /// The promise to set once the request returns.
+    std::promise<bool> m_messageCompletePromise;
+};
+
+}  // namespace deviceSetup
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
+
+#endif  //  ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_CAPABILITYAGENT_INCLUDE_DEVICESETUP_DEVICESETUPMESSAGEREQUEST_H_
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/src/CMakeLists.txt b/CapabilityAgents/DeviceSetup/capabilityagent/src/CMakeLists.txt
new file mode 100644
index 00000000..e817e7b2
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/src/CMakeLists.txt
@@ -0,0 +1,19 @@
+add_definitions("-DACSDK_LOG_MODULE=deviceSetup")
+
+add_library(
+    DeviceSetupCA SHARED
+    DeviceSetup.cpp
+    DeviceSetupMessageRequest.cpp
+)
+
+target_include_directories(DeviceSetupCA PUBLIC
+    "${DeviceSetupCA_SOURCE_DIR}/include")
+
+target_link_libraries(
+    DeviceSetupCA
+    DeviceSetupInterface
+    AVSCommon
+)
+
+# install target
+asdk_install()
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetup.cpp b/CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetup.cpp
new file mode 100644
index 00000000..a85f3a13
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetup.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/AVS/EventBuilder.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include "DeviceSetup/DeviceSetupMessageRequest.h"
+
+#include "DeviceSetup/DeviceSetup.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace deviceSetup {
+
+using namespace avsCommon::avs;
+using namespace avsCommon::sdkInterfaces;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG{"DeviceSetup"};
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/// DeviceSetup capability constants
+static const std::string DEVICESETUP_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+static const std::string DEVICESETUP_INTERFACE_NAME = "DeviceSetup";
+static const std::string DEVICESETUP_CAPABILITY_INTERFACE_VERSION = "1.0";
+
+/// The assistedSetup key.
+static const std::string ASSISTED_SETUP_KEY = "assistedSetup";
+
+/// Name of the SetupCompleted event.
+static const std::string SETUP_COMPLETED_EVENT = "SetupCompleted";
+
+std::shared_ptr<DeviceSetup> DeviceSetup::create(std::shared_ptr<MessageSenderInterface> messageSender) {
+    ACSDK_DEBUG5(LX(__func__));
+
+    if (!messageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
+        return nullptr;
+    }
+
+    return std::shared_ptr<DeviceSetup>(new DeviceSetup(messageSender));
+}
+
+DeviceSetup::DeviceSetup(std::shared_ptr<MessageSenderInterface> messageSender) : m_messageSender{messageSender} {
+}
+
+std::unordered_set<std::shared_ptr<CapabilityConfiguration>> DeviceSetup::getCapabilityConfigurations() {
+    std::unordered_map<std::string, std::string> configMap;
+    configMap.insert({CAPABILITY_INTERFACE_TYPE_KEY, DEVICESETUP_CAPABILITY_INTERFACE_TYPE});
+    configMap.insert({CAPABILITY_INTERFACE_NAME_KEY, DEVICESETUP_INTERFACE_NAME});
+    configMap.insert({CAPABILITY_INTERFACE_VERSION_KEY, DEVICESETUP_CAPABILITY_INTERFACE_VERSION});
+
+    return {std::make_shared<CapabilityConfiguration>(configMap)};
+}
+
+std::future<bool> DeviceSetup::sendDeviceSetupComplete(interfaces::deviceSetup::AssistedSetup assistedSetup) {
+    ACSDK_DEBUG5(LX(__func__).d(ASSISTED_SETUP_KEY.c_str(), assistedSetup));
+
+    avsCommon::utils::json::JsonGenerator json;
+    json.addMember(ASSISTED_SETUP_KEY, assistedSetupToString(assistedSetup));
+    std::string payload = json.toString();
+
+    std::promise<bool> sendMessagePromise;
+    std::future<bool> sendMessageFuture = sendMessagePromise.get_future();
+
+    if (payload.empty()) {
+        ACSDK_ERROR(LX(__func__).d("reason", "emptyPayload"));
+        sendMessagePromise.set_value(false);
+    } else {
+        auto msgIdAndJsonEvent =
+            buildJsonEventString(DEVICESETUP_INTERFACE_NAME, SETUP_COMPLETED_EVENT, "", payload, "");
+        auto request =
+            std::make_shared<DeviceSetupMessageRequest>(msgIdAndJsonEvent.second, std::move(sendMessagePromise));
+
+        m_messageSender->sendMessage(request);
+    }
+
+    return sendMessageFuture;
+}
+
+}  // namespace deviceSetup
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetupMessageRequest.cpp b/CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetupMessageRequest.cpp
new file mode 100644
index 00000000..c5dca406
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/src/DeviceSetupMessageRequest.cpp
@@ -0,0 +1,90 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "DeviceSetup/DeviceSetupMessageRequest.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace deviceSetup {
+
+using namespace avsCommon::avs;
+using namespace avsCommon::sdkInterfaces;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG{"DeviceSetupMessageRequest"};
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Helper function to determine whether the status is deemed successful.
+ *
+ * @param status The status.
+ * @param Whether the status is deemed successful.
+ */
+static bool isCompletedSuccessfully(MessageRequestObserverInterface::Status status) {
+    switch (status) {
+        case MessageRequestObserverInterface::Status::SUCCESS:
+        case MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED:
+        case MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT:
+            return true;
+        case MessageRequestObserverInterface::Status::PENDING:
+        case MessageRequestObserverInterface::Status::THROTTLED:
+        case MessageRequestObserverInterface::Status::NOT_CONNECTED:
+        case MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED:
+        case MessageRequestObserverInterface::Status::TIMEDOUT:
+        case MessageRequestObserverInterface::Status::PROTOCOL_ERROR:
+        case MessageRequestObserverInterface::Status::INTERNAL_ERROR:
+        case MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2:
+        case MessageRequestObserverInterface::Status::REFUSED:
+        case MessageRequestObserverInterface::Status::CANCELED:
+        case MessageRequestObserverInterface::Status::INVALID_AUTH:
+        case MessageRequestObserverInterface::Status::BAD_REQUEST:
+        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
+        default:
+            return false;
+    }
+}
+
+DeviceSetupMessageRequest::DeviceSetupMessageRequest(
+    const std::string& jsonContent,
+    std::promise<bool> messageCompletePromise) :
+        MessageRequest{jsonContent},
+        m_isPromiseSet{false},
+        m_messageCompletePromise{std::move(messageCompletePromise)} {
+}
+
+void DeviceSetupMessageRequest::sendCompleted(MessageRequestObserverInterface::Status status) {
+    MessageRequest::sendCompleted(status);
+
+    if (!m_isPromiseSet.exchange(true)) {
+        bool success = isCompletedSuccessfully(status);
+        ACSDK_DEBUG5(LX(__func__).d("status", status).d("success", success));
+        m_messageCompletePromise.set_value(success);
+    } else {
+        // Should never be called multiple times.
+        ACSDK_ERROR(LX("setPromiseFailed").d("reason", "promiseAlreadySet").d("status", status));
+    }
+}
+
+}  // namespace deviceSetup
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/test/CMakeLists.txt b/CapabilityAgents/DeviceSetup/capabilityagent/test/CMakeLists.txt
new file mode 100644
index 00000000..c5bff319
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/test/CMakeLists.txt
@@ -0,0 +1,11 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+    "${DeviceSetupCA_INCLUDE_DIRS}"
+    "${AVSCommon_SOURCE_DIR}/AVS/test")
+
+set(LIBS
+        "DeviceSetupCA"
+        "SDKInterfacesTests")
+
+discover_unit_tests("${INCLUDE_PATH}" "${LIBS}")
diff --git a/CapabilityAgents/DeviceSetup/capabilityagent/test/DeviceSetupTest.cpp b/CapabilityAgents/DeviceSetup/capabilityagent/test/DeviceSetupTest.cpp
new file mode 100644
index 00000000..c0c108aa
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/capabilityagent/test/DeviceSetupTest.cpp
@@ -0,0 +1,208 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/SDKInterfaces/MockMessageSender.h>
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+#include <rapidjson/document.h>
+
+#include "DeviceSetup/DeviceSetup.h"
+#include "DeviceSetup/DeviceSetupMessageRequest.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace deviceSetup {
+namespace test {
+
+using namespace avsCommon::avs;
+using namespace interfaces::deviceSetup;
+using namespace avsCommon::sdkInterfaces::test;
+using namespace avsCommon::utils;
+using namespace rapidjson;
+using namespace ::testing;
+
+/// The namespace for Device Setup.
+static const std::string DEVICE_SETUP_NAMESPACE{"DeviceSetup"};
+
+/// The SetupCompleted event.
+static const std::string SETUP_COMPLETED_EVENT{"SetupCompleted"};
+
+/// A long timeout to ensure that an event does occur.
+static std::chrono::seconds TIMEOUT{5};
+
+class DeviceSetupTest : public ::testing::Test {
+public:
+    /// SetUp before each test.
+    void SetUp();
+
+protected:
+    /// Mock message sender to set expectations against events.
+    std::shared_ptr<MockMessageSender> m_mockMessageSender;
+
+    /// A pointer to an instance of the DeviceSetup that will be instantiated per test.
+    std::shared_ptr<DeviceSetup> m_deviceSetup;
+};
+
+void DeviceSetupTest::SetUp() {
+    m_mockMessageSender = std::make_shared<MockMessageSender>();
+    m_deviceSetup = DeviceSetup::create(m_mockMessageSender);
+}
+
+/**
+ * Custom matcher to check an event with the correct assistedSetup value is sent.
+ * Returns true if the event matching that criteria is sent.
+ *
+ * @param expectedNamespace The expected namespace of the event.
+ * @param expectedName The expected name of the event.
+ * @param assistedSetup The expected assistedSetup of the event.
+ * @return true if an event matching the criteria is sent, false otherwise.
+ */
+MATCHER_P3(
+    EventNamed,
+    /* std::string */ expectedNameSpace,
+    /* std::string */ expectedName,
+    /* deviceSetup::AssistedSetup */ expectedAssistedSetup,
+    "") {
+    // Throw obvious compile error if not a MessageRequest.
+    std::shared_ptr<MessageRequest> request = arg;
+
+    if (!request) {
+        return false;
+    }
+
+    rapidjson::Document document;
+    ParseResult result = document.Parse(request->getJsonContent());
+
+    if (!result) {
+        return false;
+    }
+
+    rapidjson::Value::ConstMemberIterator eventIt;
+    rapidjson::Value::ConstMemberIterator headerIt;
+    rapidjson::Value::ConstMemberIterator payloadIt;
+    if (!json::jsonUtils::findNode(document, "event", &eventIt) ||
+        !json::jsonUtils::findNode(eventIt->value, "header", &headerIt) ||
+        !json::jsonUtils::findNode(eventIt->value, "payload", &payloadIt)) {
+        return false;
+    }
+
+    std::string name;
+    std::string nameSpace;
+
+    if (!json::jsonUtils::retrieveValue(headerIt->value, "name", &name) ||
+        !json::jsonUtils::retrieveValue(headerIt->value, "namespace", &nameSpace) || nameSpace != expectedNameSpace ||
+        name != expectedName) {
+        return false;
+    }
+
+    std::string assistedSetup;
+
+    if (!json::jsonUtils::retrieveValue(payloadIt->value, "assistedSetup", &assistedSetup) ||
+        assistedSetup != assistedSetupToString(expectedAssistedSetup)) {
+        return false;
+    }
+
+    return true;
+}
+
+/// Tests the constructor with nullptr as arguments.
+TEST_F(DeviceSetupTest, constructorNullptr) {
+    ASSERT_THAT(DeviceSetup::create(nullptr), IsNull());
+}
+
+/// Tests that sendDeviceSetupComplete sends an event.
+TEST_F(DeviceSetupTest, sendDeviceSetupComplete) {
+    EXPECT_CALL(
+        *m_mockMessageSender,
+        sendMessage(EventNamed(DEVICE_SETUP_NAMESPACE, SETUP_COMPLETED_EVENT, AssistedSetup::NONE)))
+        .WillOnce(Invoke([](std::shared_ptr<MessageRequest> request) {
+            request->sendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS);
+        }));
+
+    auto futureResult = m_deviceSetup->sendDeviceSetupComplete(AssistedSetup::NONE);
+    ASSERT_TRUE(futureResult.valid());
+    ASSERT_THAT(futureResult.wait_for(TIMEOUT), std::future_status::ready);
+    ASSERT_TRUE(futureResult.get());
+}
+
+/// Tests that if sending an event fails, sendDevicesSetupComplete returns false.
+TEST_F(DeviceSetupTest, sendDevicesSetupCompleteFails) {
+    EXPECT_CALL(
+        *m_mockMessageSender,
+        sendMessage(EventNamed(DEVICE_SETUP_NAMESPACE, SETUP_COMPLETED_EVENT, AssistedSetup::NONE)))
+        .WillOnce(Invoke([](std::shared_ptr<MessageRequest> request) {
+            request->sendCompleted(
+                avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2);
+        }));
+
+    auto futureResult = m_deviceSetup->sendDeviceSetupComplete(AssistedSetup::NONE);
+    ASSERT_TRUE(futureResult.valid());
+    ASSERT_THAT(futureResult.wait_for(TIMEOUT), std::future_status::ready);
+    ASSERT_FALSE(futureResult.get());
+}
+
+/// Tests that receiving an exception upon sendDevicesSetupComplete.
+TEST_F(DeviceSetupTest, sendDevicesSetupCompleteException) {
+    EXPECT_CALL(
+        *m_mockMessageSender,
+        sendMessage(EventNamed(DEVICE_SETUP_NAMESPACE, SETUP_COMPLETED_EVENT, AssistedSetup::NONE)))
+        .WillOnce(Invoke([](std::shared_ptr<MessageRequest> request) {
+            request->exceptionReceived("Exception");
+            request->sendCompleted(
+                avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2);
+        }));
+
+    auto futureResult = m_deviceSetup->sendDeviceSetupComplete(AssistedSetup::NONE);
+    ASSERT_TRUE(futureResult.valid());
+    ASSERT_THAT(futureResult.wait_for(TIMEOUT), std::future_status::ready);
+    ASSERT_FALSE(futureResult.get());
+}
+
+/// Test sending multiple requests and distinguish between them.
+TEST_F(DeviceSetupTest, sendDevicesSetupCompleteMultiple) {
+    EXPECT_CALL(
+        *m_mockMessageSender,
+        sendMessage(EventNamed(DEVICE_SETUP_NAMESPACE, SETUP_COMPLETED_EVENT, AssistedSetup::NONE)))
+        .WillOnce(Invoke([](std::shared_ptr<MessageRequest> request) {
+            request->sendCompleted(
+                avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2);
+        }));
+
+    EXPECT_CALL(
+        *m_mockMessageSender,
+        sendMessage(
+            EventNamed(DEVICE_SETUP_NAMESPACE, SETUP_COMPLETED_EVENT, AssistedSetup::ALEXA_COMPANION_APPLICATION)))
+        .WillOnce(Invoke([](std::shared_ptr<MessageRequest> request) {
+            request->sendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS);
+        }));
+
+    auto futureFail = m_deviceSetup->sendDeviceSetupComplete(AssistedSetup::NONE);
+    auto futureSucceed = m_deviceSetup->sendDeviceSetupComplete(AssistedSetup::ALEXA_COMPANION_APPLICATION);
+
+    ASSERT_TRUE(futureSucceed.valid());
+    ASSERT_THAT(futureSucceed.wait_for(TIMEOUT), std::future_status::ready);
+    ASSERT_TRUE(futureSucceed.get());
+
+    ASSERT_TRUE(futureFail.valid());
+    ASSERT_THAT(futureFail.wait_for(TIMEOUT), std::future_status::ready);
+    ASSERT_FALSE(futureFail.get());
+}
+
+}  // namespace test
+}  // namespace deviceSetup
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
diff --git a/CapabilityAgents/DeviceSetup/interface/Android.mk b/CapabilityAgents/DeviceSetup/interface/Android.mk
new file mode 100644
index 00000000..b4677d33
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/interface/Android.mk
@@ -0,0 +1,24 @@
+LOCAL_PATH:= $(call my-dir)
+
+DeviceSetup_INTERFACES := $(LOCAL_PATH)/include
+
+#########################
+# Build the shared library
+include $(CLEAR_VARS)
+LOCAL_C_INCLUDES := $(DeviceSetup_INTERFACES)
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(DeviceSetup_INTERFACES)
+
+LOCAL_MODULE := libDeviceSetupInterfaces
+include $(BUILD_SHARED_LIBRARY)
+
+#########################
+# Build the shared host library
+include $(CLEAR_VARS)
+
+LOCAL_C_INCLUDES := $(DeviceSetup_INTERFACES)
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(DeviceSetup_INTERFACES)
+
+LOCAL_MODULE := libDeviceSetupInterfaces-host
+LOCAL_MULTILIB := 64
+
+include $(BUILD_HOST_SHARED_LIBRARY)
\ No newline at end of file
diff --git a/CapabilityAgents/DeviceSetup/interface/CMakeLists.txt b/CapabilityAgents/DeviceSetup/interface/CMakeLists.txt
new file mode 100644
index 00000000..9132964f
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/interface/CMakeLists.txt
@@ -0,0 +1,9 @@
+cmake_minimum_required(VERSION 3.0)
+project(DeviceSetupInterface LANGUAGES CXX)
+
+add_library(DeviceSetupInterface INTERFACE)
+
+target_include_directories(DeviceSetupInterface INTERFACE "${DeviceSetupInterface_SOURCE_DIR}/include")
+
+# install target
+asdk_install_interface()
diff --git a/CapabilityAgents/DeviceSetup/interface/include/DeviceSetup/Interfaces/DeviceSetupInterface.h b/CapabilityAgents/DeviceSetup/interface/include/DeviceSetup/Interfaces/DeviceSetupInterface.h
new file mode 100644
index 00000000..cb1f1439
--- /dev/null
+++ b/CapabilityAgents/DeviceSetup/interface/include/DeviceSetup/Interfaces/DeviceSetupInterface.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_INTERFACE_INCLUDE_DEVICESETUP_INTERFACES_DEVICESETUPINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_INTERFACE_INCLUDE_DEVICESETUP_INTERFACES_DEVICESETUPINTERFACE_H_
+
+#include <future>
+#include <memory>
+#include <ostream>
+#include <string>
+
+namespace alexaClientSDK {
+namespace interfaces {
+namespace deviceSetup {
+
+/// Indicates if setup was assisted by another device or application.
+enum class AssistedSetup {
+    /// Setup occurred only on the device.
+    NONE,
+    /// Setup occurred with assistance from the companion app.
+    ALEXA_COMPANION_APPLICATION
+};
+
+/**
+ * Converts the @c AssistedSetup enum to a string.
+ *
+ * @param assistedSetup The @c AssistedSetup to convert.
+ * @return A string representation of the @c AssistedSetup.
+ */
+inline std::string assistedSetupToString(AssistedSetup assistedSetup) {
+    switch (assistedSetup) {
+        case AssistedSetup::NONE:
+            return "NONE";
+        case AssistedSetup::ALEXA_COMPANION_APPLICATION:
+            return "ALEXA_COMPANION_APPLICATION";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Overload for the @c AssistedSetup enum. This will write the @c AssistedSetup as a string to the provided stream.
+ *
+ * @param stream An ostream to send the @c AssistedSetup as a string.
+ * @param assisstedSetup The @c AssistedSetup to convert.
+ * @return The stream.
+ */
+inline std::ostream& operator<<(std::ostream& stream, AssistedSetup assistedSetup) {
+    return stream << assistedSetupToString(assistedSetup);
+}
+
+/// Satisfies the AVS DeviceSetup Interface.
+class DeviceSetupInterface {
+public:
+    /// Destructor.
+    virtual ~DeviceSetupInterface() = default;
+
+    /**
+     * Sends the DeviceSetup.SetupCompleted event to the cloud. Retry logic and guarantee of delivery are not
+     * expected. There may be a long roundtrip of the event, so it is recommended that clients wait with a timeout on
+     * the future.
+     *
+     * @param assistedSetup Indicates what type of assistance was used.
+     * @return A future indicating @c true if the event was sent successfully, @c false otherwise.
+     */
+    virtual std::future<bool> sendDeviceSetupComplete(AssistedSetup assistedSetup) = 0;
+};
+
+}  // namespace deviceSetup
+}  // namespace interfaces
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVS_CAPABILITIES_DEVICESETUP_INTERFACE_INCLUDE_DEVICESETUP_INTERFACES_DEVICESETUPINTERFACE_H_
diff --git a/CapabilityAgents/Messaging/CMakeLists.txt b/CapabilityAgents/Messaging/CMakeLists.txt
new file mode 100644
index 00000000..3450990e
--- /dev/null
+++ b/CapabilityAgents/Messaging/CMakeLists.txt
@@ -0,0 +1,5 @@
+cmake_minimum_required(VERSION 3.0)
+project(Messaging LANGUAGES CXX)
+
+add_subdirectory("src")
+add_subdirectory("test")
diff --git a/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
new file mode 100644
index 00000000..56d420a9
--- /dev/null
+++ b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
@@ -0,0 +1,513 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+
+#include <memory>
+#include <unordered_set>
+#include <unordered_map>
+
+#include <AVSCommon/AVS/CapabilityAgent.h>
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h>
+#include <AVSCommon/SDKInterfaces/StateProviderInterface.h>
+#include <AVSCommon/Utils/RequiresShutdown.h>
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/UUIDGeneration/UUIDGeneration.h>
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+/**
+ * This class implements the @c MessagingController capability agent.
+ *
+ * @see https://developer.amazon.com/docs/alexa-voice-service/
+ *
+ * @note For instances of this class to be cleaned up correctly, @c shutdown() must be called.
+ * @note This class makes use of a global configuration to a database file, meaning that it is best used
+ * as a singleton.
+ */
+class MessagingCapabilityAgent
+        : public avsCommon::avs::CapabilityAgent
+        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public avsCommon::utils::RequiresShutdown
+        , public std::enable_shared_from_this<MessagingCapabilityAgent> {
+public:
+    /**
+     * Messaging endpoint reference.
+     */
+    using MessagingEndpoint = avsCommon::sdkInterfaces::messaging::MessagingObserverInterface::MessagingEndpoint;
+
+    /**
+     * An enum representing the status error codes.
+     */
+    enum class StatusErrorCode {
+        /// Generic failure occurred during request processing.
+        GENERIC_FAILURE,
+
+        /// No connection was found during request processing.
+        NO_CONNECTIVITY,
+
+        /// Messaging endpoint does not have needed permissions.
+        NO_PERMISSION
+    };
+
+    /**
+     * An enum representing the @c UploadMode.
+     */
+    enum class UploadMode {
+        /// Existing messages should be deleted and replaced with uploaded ones.
+        DELETE_ALL_AND_STORE
+    };
+
+    /**
+     * An enum representing the @c ConnectionState.
+     */
+    enum class ConnectionState {
+        /// Messaging endpoint is disconnected.
+        DISCONNECTED,
+
+        /// Messaging endpoint is connected.
+        CONNECTED
+    };
+
+    /**
+     * An enum representing the @c Permission for @sa ConversationsReport.
+     */
+    enum class PermissionState {
+        /// Permission is turned off.
+        OFF,
+
+        /// Permission is turned on.
+        ON
+    };
+
+    /*
+     *  Defines a container for the messaging endpoint state.
+     */
+    struct MessagingEndpointState {
+        /*
+         * Constructor. Initializes the configuration to default.
+         */
+        MessagingEndpointState() :
+                connection{ConnectionState::DISCONNECTED},
+                sendPermission{PermissionState::OFF},
+                readPermission{PermissionState::OFF} {};
+
+        /**
+         * Constructor for initializing with specified states.
+         * @param connectionIn The state of the connection.
+         * @param sendPermission The state of the send permission.
+         * @param readPermission The state of the read permission.
+         */
+        MessagingEndpointState(
+            ConnectionState connectionIn,
+            PermissionState sendPermissionIn,
+            PermissionState readPermissionIn) :
+                connection{connectionIn}, sendPermission{sendPermissionIn}, readPermission{readPermissionIn} {
+        }
+
+        /// Connection state
+        ConnectionState connection;
+
+        /// Send permission state.
+        PermissionState sendPermission;
+
+        /// Read permission state.
+        PermissionState readPermission;
+    };
+
+    /**
+     * Destructor.
+     */
+    virtual ~MessagingCapabilityAgent() = default;
+
+    /**
+     * Factory method to create a @c MessagingCapabilityAgent instance.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide messaging state to AVS.
+     * @param messageSender Interface to send events to AVS.
+     * @return A new instance of @c MessagingCapabilityAgent on success, @c nullptr otherwise.
+     */
+    static std::shared_ptr<MessagingCapabilityAgent> create(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /// @name CapabilityAgent Functions
+    /// @{
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    /// @}
+
+    /// @name CapabilityConfigurationInterface method
+    /// @{
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    /// @}
+
+    /// @name RequiresShutdown method
+    /// @{
+    void doShutdown() override;
+    /// @}
+
+    /// @name StateProviderInterface Functions
+    /// @{
+    void provideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken) override;
+    /// @}
+
+    /**
+     * Adds an observer to @c MessagingCapabilityAgent so that it will get notified for all
+     * messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface to add.
+     */
+    void addObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Removes an observer from @c MessagingCapabilityAgent so that it will no longer be
+     * notified of messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface
+     */
+    void removeObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Sends an event to notify AVS of new messages available on the device.
+     *
+     * @note This method should be called when the device is connected.
+     * @note If this is called in response to an @c UploadConversations directive, then the token
+     * received in @c UploadConversations should be passed back. Otherwise, an empty string should be sent.
+     *
+     * @param The token received from @c uploadConversations, otherwise an empty string.
+     * @param conversations A JSON array representing the unread messages of the messaging endpoint.
+     * @code{.json}
+     * [
+     *     {
+     *         "id": "{{STRING}}",
+     *         "otherParticipants": [
+     *             {
+     *                 "address":"{{STRING}}",
+     *                 "addressType":"PhoneNumberAddress"
+     *             }
+     *         ],
+     *         "messages": [
+     *             {
+     *                 "id":"{{STRING}}",
+     *                 "payload": {
+     *                     "@type":"text",
+     *                     "text":"{{STRING}}"
+     *                 },
+     *                 "status":"unread",
+     *                 "createdTime":"{{STRING}}",
+     *                 "sender": {
+     *                     "address":"{{STRING}}",
+     *                     "addressType":"PhoneNumberAddress"
+     *                 }
+     *             }
+     *         ],
+     *         "unreadMessageCount":1
+     *     }
+     * ]
+     * @endcode
+     * @li id A unique identifier generated by the application for the conversation.
+     * @li otherParticipants Optional recipients if messages are part of a group conversation, otherwise empty JSON
+     * array.
+     * @li otherParticipants.address The phone number of the recipient.
+     * @li otherParticipants.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li messages.id A unique identifier generated by the application for the message.
+     * @li messages.payload.@type Hard coded string "text" indicating the value of the @c text field.
+     * @li messages.text The text for the message.
+     * @li messages.createdTime (optional) The ISO 8601 timestamp of when the message was created on the device.
+     * @li messages.sender.address The phone number of the sender.
+     * @li messages.sender.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li unreadMessageCount The total number of unread messages in this conversation..
+     */
+    void conversationsReport(
+        const std::string& token,
+        const std::string& conversations,
+        UploadMode mode = UploadMode::DELETE_ALL_AND_STORE,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message was sent successfully.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param messagingEndpoint The messaging endpoint that sent the message successfully.
+     */
+    void sendMessageSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message failed to be sent.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to send the message.
+     */
+    void sendMessageFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request was successful.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::updateMessagesStatus request.
+     * @param messagingEndpoint The messaging endpoint that update status successfully.
+     */
+    void updateMessagesStatusSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request failed.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to update status.
+     */
+    void updateMessagesStatusFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * This function updates the @c MessagingCapabilityAgent context.
+     *
+     * @param messagingEndpointState The current state of the messaging endpoint.
+     * @param messagingEndpoint The messaging endpoint whose state will be updated.
+     */
+    void updateMessagingEndpointState(
+        MessagingEndpointState messagingEndpointState,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide state to AVS.
+     * @param messageSender Interface to send events to AVS
+     */
+    MessagingCapabilityAgent(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /**
+     * Initializes the object.
+     */
+    bool initialize();
+
+    /**
+     * Prepares MessagingController Interface DCF configuration and keeps it internally.
+     */
+    void generateCapabilityConfiguration();
+
+    /**
+     * Builds JSON string for the device capabilities reported.
+     */
+    std::string buildMessagingEndpointConfigurationJson();
+
+    /**
+     * Remove a directive from the map of message IDs to DirectiveInfo instances.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective whose message ID is to be removed.
+     */
+    void removeDirective(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Marks the directive as completed.
+     *
+     * @param info The directive currently being handled.
+     */
+    void executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Handles the @c SendMessage AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeSendMessageDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UpdateMessagesStatus AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeUpdateMessagesStatusDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UploadConversations AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload*
+     */
+    bool executeUploadConversationsDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * This function updates the context for the @c MessagingCapabilityAgent.
+     */
+    void executeUpdateMessagingEndpointContext();
+
+    /**
+     * Gets the current state of the messaging endpoint and notifies @c ContextManager
+     *
+     * @param stateProviderName Provides the property name and used in the @c ContextManager methods.
+     * @param contextRequestToken The token to be used when providing the response to @c ContextManager
+     */
+    void executeProvideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken);
+
+    /// The ContextManager object.
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
+
+    /// The regular MessageSender object.
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+
+    /// Set of capability configurations that will get published using DCF
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+
+    /// Set of observers of MessagingObserverInterface.
+    std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface>> m_observers;
+
+    /// Map of messaging endpoint to state
+    std::unordered_map<std::string, MessagingEndpointState> m_messagingEndpointsState;
+
+    /// The current context for the messaging capability agent
+    std::string m_messagingContext;
+
+    /// Mutex to guard access of m_observers.
+    std::mutex m_observerMutex;
+
+    /// An executor used for serializing requests.
+    avsCommon::utils::threading::Executor m_executor;
+};
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param messagingEndpoint The @c MessagingEndpoint value.
+ * @return The string form of the enum.
+ */
+inline std::string messagingEndpointToString(MessagingCapabilityAgent::MessagingEndpoint messagingEndpoint) {
+    switch (messagingEndpoint) {
+        case MessagingCapabilityAgent::MessagingEndpoint::DEFAULT:
+            return "DEFAULT";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c StatusErrorCode.
+ * @return The string form of the enum.
+ */
+inline std::string statusErrorCodeToString(MessagingCapabilityAgent::StatusErrorCode code) {
+    switch (code) {
+        case MessagingCapabilityAgent::StatusErrorCode::GENERIC_FAILURE:
+            return "GENERIC_FAILURE";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_CONNECTIVITY:
+            return "NO_CONNECTIVITY";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_PERMISSION:
+            return "NO_PERMISSION";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c UploadMode.
+ * @return The string form of the enum.
+ */
+inline std::string uploadModeToString(MessagingCapabilityAgent::UploadMode mode) {
+    switch (mode) {
+        case MessagingCapabilityAgent::UploadMode::DELETE_ALL_AND_STORE:
+            return "DELETE_ALL_AND_STORE";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c ConnectionState.
+ * @return The string form of the enum.
+ */
+inline std::string connectionStateToString(MessagingCapabilityAgent::ConnectionState connection) {
+    switch (connection) {
+        case MessagingCapabilityAgent::ConnectionState::CONNECTED:
+            return "CONNECTED";
+        case MessagingCapabilityAgent::ConnectionState::DISCONNECTED:
+            return "DISCONNECTED";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c PermissionState.
+ * @return The string form of the enum.
+ */
+inline std::string permissionStateToString(MessagingCapabilityAgent::PermissionState permission) {
+    switch (permission) {
+        case MessagingCapabilityAgent::PermissionState::ON:
+            return "ON";
+        case MessagingCapabilityAgent::PermissionState::OFF:
+            return "OFF";
+    }
+
+    return "UNKNOWN";
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/src/CMakeLists.txt b/CapabilityAgents/Messaging/src/CMakeLists.txt
new file mode 100644
index 00000000..ad7b3555
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/CMakeLists.txt
@@ -0,0 +1,13 @@
+add_definitions("-DACSDK_LOG_MODULE=messaging")
+
+add_library(Messaging SHARED
+        MessagingCapabilityAgent.cpp)
+
+target_include_directories(Messaging PUBLIC
+        "${Messaging_SOURCE_DIR}/include"
+        "${AVSCommon_INCLUDE_DIRS}")
+
+target_link_libraries(Messaging AVSCommon)
+
+# install target
+asdk_install()
diff --git a/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
new file mode 100644
index 00000000..188016ba
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
@@ -0,0 +1,697 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <rapidjson/document.h>
+#include <rapidjson/error/en.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/AVS/MessageRequest.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "Messaging/MessagingCapabilityAgent.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+using namespace avsCommon::avs;
+using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::sdkInterfaces::messaging;
+using namespace avsCommon::utils::json::jsonUtils;
+using namespace avsCommon::utils::json;
+using namespace avsCommon::utils::logger;
+using namespace rapidjson;
+
+// ==== Messaging Capability Agent constants ===
+
+/// String to identify log entries originating from this file.
+static const std::string TAG{"Messaging"};
+
+/// The MessagingController interface namespace.
+static const std::string NAMESPACE{"Alexa.Comms.MessagingController"};
+
+/// MessagingController interface type.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+
+/// MessagingController interface version.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_VERSION = "1.0";
+
+/// The MessagingController context namespace.
+static const NamespaceAndName CONTEXT_MANAGER_MESSAGING_STATE{NAMESPACE, "MessagingControllerState"};
+
+// ==== Directives ===
+
+/// The @c SendMessage directive identifier.
+static const NamespaceAndName SEND_MESSAGE{NAMESPACE, "SendMessage"};
+
+/// The @c UpdateMessagesStatus directive identifier.
+static const NamespaceAndName UPDATE_MESSAGES_STATUS{NAMESPACE, "UpdateMessagesStatus"};
+
+/// The @c UploadConversations directive identifier.
+static const NamespaceAndName UPLOAD_CONVERSATIONS{NAMESPACE, "UploadConversations"};
+
+// ==== Events ===
+
+/// The @c SendMessageSucceeded event identifier.
+static const std::string SEND_MESSAGE_SUCCEEDED = "SendMessageSucceeded";
+
+/// The @c SendMessageFailed event identifier.
+static const std::string SEND_MESSAGE_FAILED = "SendMessageFailed";
+
+/// The @c UpdateMessagesStatusSucceeded event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_SUCCEEDED = "UpdateMessagesStatusSucceeded";
+
+/// The @c UpdateMessagesStatusFailed event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_FAILED = "UpdateMessagesStatusFailed";
+
+/// The @c ConversationsReport event identifier.
+static const std::string CONVERSATIONS_REPORT = "ConversationsReport";
+
+// ==== JSON constants ===
+
+/// Name for "token" JSON key.
+static constexpr char JSON_KEY_TOKEN[] = "token";
+
+/// Name for "conversationId" JSON key.
+static constexpr char JSON_KEY_CONVERSATION_ID[] = "conversationId";
+
+/// Name for "statusMap" JSON key.
+static constexpr char JSON_KEY_STATUS_MAP[] = "statusMap";
+
+/// Name for "messagingEndpoints" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINTS[] = "messagingEndpoints";
+
+/// Name for "messagingEndpointInfo" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_INFO[] = "messagingEndpointInfo";
+
+/// Name for "name" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_NAME[] = "name";
+
+/// Name for "messagingEndpointStates" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_STATES[] = "messagingEndpointStates";
+
+/// Name for "permissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_PERMISSIONS[] = "permissions";
+
+/// Name for "sendPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_SEND_PERMISSION[] = "sendPermission";
+
+/// Name for "readPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_READ_PERMISSION[] = "readPermission";
+
+/// Name for "connectionState" JSON key.
+static constexpr char JSON_KEY_CONNECTION_STATE[] = "connectionState";
+
+/// Name for "status" JSON value.
+static constexpr char JSON_KEY_STATUS[] = "status";
+
+/// Name for "uploadMode" JSON value.
+static constexpr char JSON_KEY_UPLOAD_MODE[] = "uploadMode";
+
+/// Name for "code" JSON key.
+static constexpr char JSON_KEY_STATUS_CODE[] = "code";
+
+/// Name for "message" JSON key.
+static constexpr char JSON_KEY_STATUS_MESSAGE[] = "message";
+
+/// Name for "conversations" JSON key.
+static constexpr char JSON_KEY_CONVERSATIONS[] = "conversations";
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<MessagingCapabilityAgent> MessagingCapabilityAgent::create(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) {
+    if (!contextManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
+        return nullptr;
+    }
+
+    if (!exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionSender"));
+        return nullptr;
+    }
+
+    if (!messageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
+        return nullptr;
+    }
+
+    // Create instance of capability agent
+    auto messagingCapabilityAgent = std::shared_ptr<MessagingCapabilityAgent>(
+        new MessagingCapabilityAgent(exceptionSender, contextManager, messageSender));
+
+    messagingCapabilityAgent->initialize();
+
+    return messagingCapabilityAgent;
+}
+
+MessagingCapabilityAgent::MessagingCapabilityAgent(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) :
+        CapabilityAgent{NAMESPACE, exceptionSender},
+        avsCommon::utils::RequiresShutdown{"MessagingCapabilityAgent"},
+        m_contextManager{contextManager},
+        m_messageSender{messageSender} {
+}
+
+bool MessagingCapabilityAgent::initialize() {
+    ACSDK_INFO(LX(__func__));
+    // Initialize endpoint state values. One per defined messaging endpoint.
+    m_messagingEndpointsState.emplace(messagingEndpointToString(MessagingEndpoint::DEFAULT), MessagingEndpointState{});
+    // Generate the device capability configuration
+    generateCapabilityConfiguration();
+    // Register with the context manager
+    m_contextManager->addStateProvider(CONTEXT_MANAGER_MESSAGING_STATE, shared_from_this());
+    // Initialize the context
+    executeUpdateMessagingEndpointContext();
+
+    return true;
+}
+
+void MessagingCapabilityAgent::generateCapabilityConfiguration() {
+    std::unordered_map<std::string, std::string> configMap;
+
+    configMap.insert({CAPABILITY_INTERFACE_TYPE_KEY, MESSAGING_CAPABILITY_INTERFACE_TYPE});
+    configMap.insert({CAPABILITY_INTERFACE_NAME_KEY, NAMESPACE});
+    configMap.insert({CAPABILITY_INTERFACE_VERSION_KEY, MESSAGING_CAPABILITY_INTERFACE_VERSION});
+    configMap.insert({CAPABILITY_INTERFACE_CONFIGURATIONS_KEY, buildMessagingEndpointConfigurationJson()});
+
+    m_capabilityConfigurations.insert(std::make_shared<CapabilityConfiguration>(configMap));
+}
+
+std::string MessagingCapabilityAgent::buildMessagingEndpointConfigurationJson() {
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINTS);
+    jsonGenerator.startArrayElement();
+    jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+    jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(MessagingEndpoint::DEFAULT));
+    jsonGenerator.finishObject();
+    jsonGenerator.finishArrayElement();
+    jsonGenerator.finishArray();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("configuration", jsonGenerator.toString()));
+    return jsonGenerator.toString();
+}
+
+DirectiveHandlerConfiguration MessagingCapabilityAgent::getConfiguration() const {
+    DirectiveHandlerConfiguration configuration;
+    auto noneNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+
+    configuration[SEND_MESSAGE] = noneNonBlockingPolicy;
+    configuration[UPDATE_MESSAGES_STATUS] = noneNonBlockingPolicy;
+    configuration[UPLOAD_CONVERSATIONS] = noneNonBlockingPolicy;
+
+    return configuration;
+}
+
+void MessagingCapabilityAgent::provideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(
+        LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
+
+    m_executor.submit([this, stateProviderName, contextRequestToken] {
+        ACSDK_DEBUG5(LX("provideStateInExecutor"));
+        executeProvideState(stateProviderName, contextRequestToken);
+    });
+    return;
+}
+
+void MessagingCapabilityAgent::handleDirectiveImmediately(std::shared_ptr<AVSDirective> directive) {
+    ACSDK_DEBUG5(LX(__func__));
+    handleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
+}
+
+void MessagingCapabilityAgent::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
+    // No-op
+}
+
+/**
+ * Parses a directive payload JSON and returns a parsed document object.
+ *
+ * @param payload JSON string to parse.
+ * @param[out] document Pointer to a parsed document.
+ * @return True if parsing was successful, false otherwise.
+ */
+static bool parseDirectivePayload(const std::string& payload, Document* document) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!document) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed").d("reason", "nullDocument"));
+        return false;
+    }
+
+    ParseResult result = document->Parse(payload);
+    if (!result) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed")
+                        .d("reason", "parseFailed")
+                        .d("error", GetParseError_En(result.Code()))
+                        .d("offset", result.Offset()));
+        return false;
+    }
+
+    return true;
+}
+
+void MessagingCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!info) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+
+    m_executor.submit([this, info] {
+        const std::string directiveName = info->directive->getName();
+
+        Document payload(kObjectType);
+        if (!parseDirectivePayload(info->directive->getPayload(), &payload)) {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unable to parse payload", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        if (directiveName == SEND_MESSAGE.name) {
+            if (!executeSendMessageDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPDATE_MESSAGES_STATUS.name) {
+            if (!executeUpdateMessagesStatusDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPLOAD_CONVERSATIONS.name) {
+            if (!executeUploadConversationsDirective(info, payload)) {
+                return;
+            }
+        } else {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unexpected Directive", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        executeSetHandlingCompleted(info);
+    });
+}
+
+void MessagingCapabilityAgent::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
+    removeDirective(info);
+}
+
+void MessagingCapabilityAgent::addObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.insert(observer);
+}
+
+void MessagingCapabilityAgent::removeObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("removeObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.erase(observer);
+}
+
+void MessagingCapabilityAgent::removeDirective(std::shared_ptr<DirectiveInfo> info) {
+    if (info->directive && info->result) {
+        CapabilityAgent::removeDirective(info->directive->getMessageId());
+    }
+}
+
+void MessagingCapabilityAgent::executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (info && info->directive && info->result) {
+        info->result->setCompleted();
+    }
+    removeDirective(info);
+}
+
+bool MessagingCapabilityAgent::executeSendMessageDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->sendMessage(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUpdateMessagesStatusDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name, conversationId;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate conversationId field
+    if (!findNode(payload, JSON_KEY_CONVERSATION_ID, &it) ||
+        !retrieveValue(payload, JSON_KEY_CONVERSATION_ID, &conversationId) || conversationId.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'conversationId' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate statusMap field
+    if (!findNode(payload, JSON_KEY_STATUS_MAP, &it) || !it->value.IsObject()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'statusMap' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->updateMessagesStatus(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUploadConversationsDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->uploadConversations(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+std::unordered_set<std::shared_ptr<CapabilityConfiguration>> MessagingCapabilityAgent::getCapabilityConfigurations() {
+    return m_capabilityConfigurations;
+}
+
+void MessagingCapabilityAgent::doShutdown() {
+    m_executor.shutdown();
+    m_messageSender.reset();
+    // Remove state provider
+    m_contextManager->removeStateProvider(CONTEXT_MANAGER_MESSAGING_STATE);
+    m_contextManager.reset();
+}
+
+void MessagingCapabilityAgent::sendMessageSucceeded(const std::string& token, MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::sendMessageFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusSucceeded(
+    const std::string& token,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::conversationsReport(
+    const std::string& token,
+    const std::string& conversations,
+    UploadMode mode,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.addRawJsonMember(JSON_KEY_CONVERSATIONS, conversations);
+        jsonGenerator.addMember(JSON_KEY_UPLOAD_MODE, uploadModeToString(mode));
+
+        // Build event
+        auto event = buildJsonEventString(CONVERSATIONS_REPORT, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagingEndpointState(
+    MessagingEndpointState messagingEndpointState,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        // Update map
+        m_messagingEndpointsState[messagingEndpointToString(messagingEndpoint)] = messagingEndpointState;
+        executeUpdateMessagingEndpointContext();
+    });
+}
+
+void MessagingCapabilityAgent::executeUpdateMessagingEndpointContext() {
+    // Update context
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINT_STATES);
+
+    for (auto entry : m_messagingEndpointsState) {
+        jsonGenerator.startArrayElement();
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, entry.first);
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_CONNECTION_STATE, connectionStateToString(entry.second.connection));
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_PERMISSIONS);
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_SEND_PERMISSION, permissionStateToString(entry.second.sendPermission));
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_READ_PERMISSION, permissionStateToString(entry.second.readPermission));
+        jsonGenerator.finishObject();
+        jsonGenerator.finishArrayElement();
+    }
+
+    jsonGenerator.finishArray();
+
+    // Save new context
+    m_messagingContext = jsonGenerator.toString();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    m_contextManager->reportStateChange(
+        CONTEXT_MANAGER_MESSAGING_STATE,
+        CapabilityState{m_messagingContext},
+        AlexaStateChangeCauseType::APP_INTERACTION);
+}
+
+void MessagingCapabilityAgent::executeProvideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    CapabilityState state{m_messagingContext};
+    m_contextManager->provideStateResponse(stateProviderName, CapabilityState{m_messagingContext}, contextRequestToken);
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/test/CMakeLists.txt b/CapabilityAgents/Messaging/test/CMakeLists.txt
new file mode 100644
index 00000000..030a1271
--- /dev/null
+++ b/CapabilityAgents/Messaging/test/CMakeLists.txt
@@ -0,0 +1,8 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${Messaging_INCLUDE_DIRS}"
+        "${AVSCommon_SOURCE_DIR}/SDKInterfaces/test"
+        )
+
+discover_unit_tests("${INCLUDE_PATH}" "Messaging")
diff --git a/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp b/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp
index 0a1c122e..b0addce1 100644
--- a/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp
+++ b/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp
@@ -18,6 +18,7 @@
 #include <rapidjson/stringbuffer.h>
 #include <rapidjson/writer.h>
 #include <rapidjson/error/en.h>
+#include <sstream>
 
 #include <acsdkManufactory/Annotated.h>
 #include <acsdkShutdownManagerInterfaces/ShutdownNotifierInterface.h>
@@ -93,6 +94,18 @@ static bool withinBounds(T value, T min, T max) {
     return true;
 }
 
+/**
+ * Converts the @c SpeakerManagerObserverInterface::Source to a string.
+ *
+ * @param source The input @c SpeakerManagerObserverInterface::Source.
+ * @return The @c String representing the source.
+ */
+static inline std::string getSourceString(SpeakerManagerObserverInterface::Source source) {
+    std::stringstream ss;
+    ss << source;
+    return ss.str();
+}
+
 /**
  * Handles a Metric event by creating and recording it. Failure to create or record the event results
  * in an early return.
@@ -648,6 +661,8 @@ bool SpeakerManager::executeSetVolume(
         submitMetric(m_metricRecorder, "setVolumeZero", 1);
     }
 
+    submitMetric(m_metricRecorder, "setVolumeSource_" + getSourceString(properties.source), 1);
+
     auto adjustedVolume = volume;
 
     auto maximumVolumeLimit = getMaximumVolumeLimit();
@@ -765,6 +780,7 @@ bool SpeakerManager::executeAdjustVolume(
     }
 
     submitMetric(m_metricRecorder, "adjustVolume", 1);
+    submitMetric(m_metricRecorder, "adjustVolumeSource_" + getSourceString(properties.source), 1);
     SpeakerInterface::SpeakerSettings settings;
     if (!executeGetSpeakerSettings(type, &settings)) {
         ACSDK_ERROR(LX("executeAdjustVolumeFailed").d("reason", "speakerSettingsInconsistent"));
@@ -898,6 +914,12 @@ bool SpeakerManager::executeSetMute(
         ACSDK_ERROR(LX("executeSetMute").d("reason", "speakerSettingsInconsistent"));
         return false;
     }
+    settings.mute = mute;
+    if (mute) {
+        submitMetric(m_metricRecorder, "setMuteSource_" + getSourceString(properties.source), 1);
+    } else {
+        submitMetric(m_metricRecorder, "setUnMuteSource_" + getSourceString(properties.source), 1);
+    }
 
     ACSDK_DEBUG(LX("executeSetMuteSuccess").d("mute", mute));
 
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index c12b1ee6..6ac96a2f 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -295,8 +295,12 @@ void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
 }
 
 void SpeechSynthesizer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
-    ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
-    m_executor.submit([this, info]() { executeCancel(info); });
+    if (info && info->directive) {
+        ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
+        m_executor.submit([this, info]() { executeCancel(info); });
+    } else {
+        ACSDK_WARN(LX("cancelDirective").d("reason", "infoNotAvailable"));
+    }
 }
 
 void SpeechSynthesizer::onFocusChanged(FocusState newFocus, MixingBehavior behavior) {
@@ -1077,9 +1081,13 @@ std::string SpeechSynthesizer::buildPayload(std::string& token) {
 
 void SpeechSynthesizer::startPlaying() {
     ACSDK_DEBUG9(LX("startPlaying"));
-    std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
-    m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
-    if (m_captionManager && m_captionManager->isEnabled() && m_currentInfo->captionData.isValid()) {
+    if (m_currentInfo && m_currentInfo->attachmentReader) {
+        std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
+        m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    } else {
+        m_mediaSourceId = MediaPlayerInterface::ERROR;
+    }
+    if (m_captionManager && m_currentInfo->captionData.isValid()) {
         m_captionManager->onCaption(m_mediaSourceId, m_currentInfo->captionData);
     }
     if (MediaPlayerInterface::ERROR == m_mediaSourceId) {
@@ -1151,9 +1159,14 @@ void SpeechSynthesizer::setDesiredState(SpeechSynthesizerObserverInterface::Spee
 void SpeechSynthesizer::resetCurrentInfo(std::shared_ptr<SpeakDirectiveInfo> speakInfo) {
     if (m_currentInfo != speakInfo) {
         if (m_currentInfo) {
-            removeSpeakDirectiveInfo(m_currentInfo->directive->getMessageId());
-            removeDirective(m_currentInfo->directive->getMessageId());
-            m_currentInfo->clear();
+            auto info = m_currentInfo;
+            if (info) {
+                if (info->directive) {
+                    removeSpeakDirectiveInfo(info->directive->getMessageId());
+                    removeDirective(info->directive->getMessageId());
+                }
+                info->clear();
+            }
         }
         m_currentInfo = speakInfo;
     }
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 5a19ef69..ad6e0984 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -39,7 +39,7 @@ static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_TYPE = "AlexaInter
 /// TemplateRuntime interface name
 static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_NAME = "TemplateRuntime";
 /// TemplateRuntime interface version
-static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.1";
+static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.2";
 
 /// String to identify log entries originating from this file.
 static const std::string TAG{"TemplateRuntime"};
diff --git a/Endpoints/include/Endpoints/DefaultEndpointBuilder.h b/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
index 587cbbca..f56454b4 100644
--- a/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
+++ b/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
@@ -19,10 +19,12 @@
 #include <memory>
 #include <string>
 
+#include <acsdkManufactory/Annotated.h>
 #include <Alexa/AlexaInterfaceMessageSender.h>
 #include <Alexa/AlexaInterfaceMessageSenderInternalInterface.h>
 #include <AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h>
 #include <AVSCommon/SDKInterfaces/AlexaInterfaceMessageSenderInterface.h>
+#include "AVSCommon/SDKInterfaces/Endpoints/DefaultEndpointAnnotation.h"
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointRegistrationManagerInterface.h>
@@ -99,6 +101,7 @@ public:
     DefaultEndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     DefaultEndpointBuilder& withDescription(const std::string& description) override;
     DefaultEndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    DefaultEndpointBuilder& withEndpointResources(const avsCommon::avs::EndpointResources& endpointResources) override;
     DefaultEndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     DefaultEndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
diff --git a/Endpoints/include/Endpoints/EndpointAttributeValidation.h b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
index 74856249..e86f41b3 100644
--- a/Endpoints/include/Endpoints/EndpointAttributeValidation.h
+++ b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
@@ -34,6 +34,14 @@ namespace endpoints {
  */
 bool isEndpointIdValid(const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier& identifier);
 
+/**
+ * Returns whether the given endpointResources follows AVS specification.
+ *
+ * @param endpointResources The endpointResources to be validated.
+ * @return @c true if valid; otherwise, return @c false.
+ */
+bool isEndpointResourcesValid(const avsCommon::avs::EndpointResources& endpointResources);
+
 /**
  * Returns whether the given name follows AVS specification.
  *
diff --git a/Endpoints/include/Endpoints/EndpointBuilder.h b/Endpoints/include/Endpoints/EndpointBuilder.h
index 5ae5fda2..a3a6e8ec 100644
--- a/Endpoints/include/Endpoints/EndpointBuilder.h
+++ b/Endpoints/include/Endpoints/EndpointBuilder.h
@@ -103,6 +103,8 @@ public:
     EndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     EndpointBuilder& withDescription(const std::string& description) override;
     EndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    EndpointBuilder& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) override;
     EndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     EndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
@@ -208,6 +210,9 @@ private:
     /// rules apply differently.
     bool m_isDefaultEndpoint;
 
+    /// Flag used to indicate whether endpointResources is used.
+    bool m_isEndpointResourcesUsed;
+
     /// The client endpoint id that is used to build the default endpoint and generate derived endpoints.
     std::shared_ptr<avsCommon::utils::DeviceInfo> m_deviceInfo;
 
diff --git a/Endpoints/src/DefaultEndpointBuilder.cpp b/Endpoints/src/DefaultEndpointBuilder.cpp
index fce95e97..66c31d77 100644
--- a/Endpoints/src/DefaultEndpointBuilder.cpp
+++ b/Endpoints/src/DefaultEndpointBuilder.cpp
@@ -107,6 +107,12 @@ DefaultEndpointBuilder& DefaultEndpointBuilder::withManufacturerName(const std::
     return *this;
 }
 
+DefaultEndpointBuilder& DefaultEndpointBuilder::withEndpointResources(const avsCommon::avs::EndpointResources& endpointResources) {
+    ACSDK_DEBUG5(LX(__func__));
+    m_builder->withEndpointResources(endpointResources);
+    return *this;
+}
+
 DefaultEndpointBuilder& DefaultEndpointBuilder::withDisplayCategory(const std::vector<std::string>& displayCategories) {
     ACSDK_DEBUG5(LX(__func__));
     m_builder->withDisplayCategory(displayCategories);
diff --git a/Endpoints/src/EndpointAttributeValidation.cpp b/Endpoints/src/EndpointAttributeValidation.cpp
index c078d38f..5ced5929 100644
--- a/Endpoints/src/EndpointAttributeValidation.cpp
+++ b/Endpoints/src/EndpointAttributeValidation.cpp
@@ -29,6 +29,10 @@ bool isEndpointIdValid(const EndpointIdentifier& identifier) {
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_ENDPOINT_IDENTIFIER_LENGTH);
 }
 
+bool isEndpointResourcesValid(const EndpointResources& endpointResources) {
+    return endpointResources.isValid();
+}
+
 bool isFriendlyNameValid(const std::string& name) {
     auto length = name.length();
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_FRIENDLY_NAME_LENGTH);
diff --git a/Endpoints/src/EndpointBuilder.cpp b/Endpoints/src/EndpointBuilder.cpp
index 13fdfc0e..399f3c53 100644
--- a/Endpoints/src/EndpointBuilder.cpp
+++ b/Endpoints/src/EndpointBuilder.cpp
@@ -56,8 +56,8 @@ static const std::string TAG("EndpointBuilder");
 /// String used to join attributes in the generation of the derived endpoint id.
 const std::string ENDPOINT_ID_CONCAT = "::";
 
-/// We will limit the suffix length to 10 characters for now to ensure that we don't go over the endpointId length.
-static constexpr size_t MAX_SUFFIX_LENGTH = 10;
+/// We will limit the EndpointId length to 256 characters
+static constexpr size_t MAX_ENDPOINTID_LENGTH = 256;
 
 /// The display category for the AVS device endpoint;
 const std::string ALEXA_DISPLAY_CATEGORY = "ALEXA_VOICE_ENABLED";
@@ -110,6 +110,7 @@ EndpointBuilder::EndpointBuilder(
         m_hasBeenBuilt{false},
         m_invalidConfiguration{false},
         m_isDefaultEndpoint{false},
+        m_isEndpointResourcesUsed{false},
         m_deviceInfo{deviceInfo},
         m_contextManager{contextManager},
         m_exceptionSender{exceptionSender},
@@ -146,12 +147,15 @@ EndpointBuilder& EndpointBuilder::withDerivedEndpointId(const std::string& suffi
         return *this;
     }
 
-    if (suffix.length() > MAX_SUFFIX_LENGTH) {
-        ACSDK_ERROR(LX(std::string(__func__) + "Failed").d("reason", "suffixMaxLengthExceeded").d("suffix", suffix));
+    std::string fullEndpointId = m_deviceInfo->getDefaultEndpointId() + ENDPOINT_ID_CONCAT + suffix;
+    if (fullEndpointId.length() > MAX_ENDPOINTID_LENGTH) {
+        ACSDK_ERROR(LX(std::string(__func__) + "Failed")
+                        .d("reason", "EndpointIdMaxLengthExceeded")
+                        .sensitive("fullEndpointId", fullEndpointId));
         return *this;
     }
 
-    m_attributes.endpointId = m_deviceInfo->getDefaultEndpointId() + ENDPOINT_ID_CONCAT + suffix;
+    m_attributes.endpointId = fullEndpointId;
     return *this;
 }
 
@@ -176,6 +180,18 @@ void EndpointBuilder::finalizeAttributes() {
     m_isConfigurationFinalized = true;
 }
 
+EndpointBuilder& EndpointBuilder::withEndpointResources(
+        const avsCommon::avs::EndpointResources& endpointResources) {
+    m_isEndpointResourcesUsed = true;
+    if (!isEndpointResourcesValid(endpointResources)){
+        ACSDK_ERROR(LX(__func__).d("reason", "invalidEndpointResources"));
+        m_invalidConfiguration = true;
+        return *this;
+    }
+    m_attributes.endpointResources = endpointResources;
+    return *this;
+}
+
 EndpointBuilder& EndpointBuilder::withFriendlyName(const std::string& friendlyName) {
     if (m_isConfigurationFinalized) {
         ACSDK_ERROR(LX(std::string(__func__) + "Failed").d("reason", "operationNotAllowed"));
@@ -537,7 +553,14 @@ std::unique_ptr<EndpointInterface> EndpointBuilder::buildImplementation() {
         return nullptr;
     }
 
-    if (!m_isDefaultEndpoint && !isFriendlyNameValid(m_attributes.friendlyName)) {
+    if (!m_isDefaultEndpoint && m_isEndpointResourcesUsed
+                             && !isEndpointResourcesValid(m_attributes.endpointResources)) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return nullptr;
+    }
+
+    if (!m_isDefaultEndpoint && !m_isEndpointResourcesUsed
+                             && !isFriendlyNameValid(m_attributes.friendlyName)) {
         ACSDK_ERROR(
             LX("buildFailed").d("reason", "friendlyNameInvalid").sensitive("friendlyName", m_attributes.friendlyName));
         return nullptr;
diff --git a/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h b/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
index 62ef8973..1ca46917 100644
--- a/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
@@ -130,7 +130,7 @@ private:
     void inhibitSubmission();
 
     /// MetricRecorder to publish UPL metrics.
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+    std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 
     /// Time point for the start of the TTS when media plays after TTS
     UplTimePoint m_ttsStarted;
@@ -146,4 +146,4 @@ private:
 }  // namespace metrics
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_MEDIAUPLCALCULATOR_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_MEDIAUPLCALCULATOR_H_
diff --git a/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h b/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
index e9747b63..75a92dd3 100644
--- a/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
@@ -91,7 +91,7 @@ private:
     void inhibitSubmission();
 
     /// MetricRecorder to publish UPL metrics.
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+    std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 
     /// Stop UPL calculations for unwanted cases
     bool m_uplInhibited;
@@ -101,4 +101,4 @@ private:
 }  // namespace metrics
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_TTSUPLCALCULATOR_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_TTSUPLCALCULATOR_H_
diff --git a/Metrics/UplCalculator/include/Metrics/UplMetricSink.h b/Metrics/UplCalculator/include/Metrics/UplMetricSink.h
index 0577686c..04a02d3c 100644
--- a/Metrics/UplCalculator/include/Metrics/UplMetricSink.h
+++ b/Metrics/UplCalculator/include/Metrics/UplMetricSink.h
@@ -64,11 +64,11 @@ private:
         uplCalculators;
 
     /// MetricRecorder to publish UPL metrics.
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+    std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 };
 
 }  // namespace implementations
 }  // namespace metrics
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_UPLMETRICSINK_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_UPLMETRICSINK_H_
diff --git a/Metrics/UplCalculator/src/MediaUplCalculator.cpp b/Metrics/UplCalculator/src/MediaUplCalculator.cpp
index e0fb7a0b..1817b390 100644
--- a/Metrics/UplCalculator/src/MediaUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/MediaUplCalculator.cpp
@@ -295,8 +295,12 @@ void MediaUplCalculator::calculateMediaUpl(MediaUplType type) {
                                         .setName(DIALOG_REQUEST_ID_TAG)
                                         .setValue(m_uplData->getStringData(DIALOG_REQUEST_ID_TAG))
                                         .build());
-
-    m_metricRecorder->recordMetric(metricEventBuilder.build());
+    auto metricRecorder = m_metricRecorder.lock();
+    if (metricRecorder) {
+        metricRecorder->recordMetric(metricEventBuilder.build());
+    } else {
+        ACSDK_ERROR(LX("calculateMediaUplFailed").d("reason", "nullMetricRecorder"));
+    }
     inhibitSubmission();
 }
 
@@ -306,4 +310,4 @@ void MediaUplCalculator::inhibitSubmission() {
 
 }  // namespace implementations
 }  // namespace metrics
-}  // namespace alexaClientSDK
\ No newline at end of file
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/src/TtsUplCalculator.cpp b/Metrics/UplCalculator/src/TtsUplCalculator.cpp
index 7f12ff6b..97174c3c 100644
--- a/Metrics/UplCalculator/src/TtsUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/TtsUplCalculator.cpp
@@ -174,8 +174,12 @@ void TtsUplCalculator::calculateTtsUpl() {
                                         .setName(DIALOG_REQUEST_ID_TAG)
                                         .setValue(m_uplData->getStringData(DIALOG_REQUEST_ID_TAG))
                                         .build());
-
-    m_metricRecorder->recordMetric(metricEventBuilder.build());
+    auto metricsRecorder = m_metricRecorder.lock();
+    if (metricsRecorder) {
+        metricsRecorder->recordMetric(metricEventBuilder.build());
+    } else {
+        ACSDK_ERROR(LX("calculateTtsUplFailed").d("reason", "nullMetricRecorder"));
+    }
     inhibitSubmission();
 }
 
@@ -185,4 +189,4 @@ void TtsUplCalculator::inhibitSubmission() {
 
 }  // namespace implementations
 }  // namespace metrics
-}  // namespace alexaClientSDK
\ No newline at end of file
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/src/UplMetricSink.cpp b/Metrics/UplCalculator/src/UplMetricSink.cpp
index 00e2da68..2193a609 100644
--- a/Metrics/UplCalculator/src/UplMetricSink.cpp
+++ b/Metrics/UplCalculator/src/UplMetricSink.cpp
@@ -68,13 +68,15 @@ void UplMetricSink::consumeMetric(std::shared_ptr<alexaClientSDK::avsCommon::uti
     // Reset UPL data on the start of a new utterance
     if (metricName == START_OF_UTTERANCE) {
         uplCalculators[BASE_UPL_NAME] = BaseUplCalculator::createBaseUplCalculator();
-        uplCalculators[TTS_UPL_NAME] = TtsUplCalculator::createTtsUplCalculator(m_metricRecorder);
-        uplCalculators[MEDIA_UPL_NAME] = MediaUplCalculator::createMediaUplCalculator(m_metricRecorder);
-
-        std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
-            std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
-        for (auto& kv : uplCalculators) {
-            kv.second->setUplData(uplData);
+        auto metricRecorder = m_metricRecorder.lock();
+        if (metricRecorder) {
+            uplCalculators[TTS_UPL_NAME] = TtsUplCalculator::createTtsUplCalculator(metricRecorder);
+            uplCalculators[MEDIA_UPL_NAME] = MediaUplCalculator::createMediaUplCalculator(metricRecorder);
+            std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+                std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+            for (auto& kv : uplCalculators) {
+                kv.second->setUplData(uplData);
+            }
         }
     }
 
@@ -87,4 +89,4 @@ void UplMetricSink::consumeMetric(std::shared_ptr<alexaClientSDK::avsCommon::uti
 
 }  // namespace implementations
 }  // namespace metrics
-}  // namespace alexaClientSDK
\ No newline at end of file
+}  // namespace alexaClientSDK
diff --git a/RegistrationManager/include/RegistrationManager/RegistrationManager.h b/RegistrationManager/include/RegistrationManager/RegistrationManager.h
index 37fe4c6e..3b8425cc 100644
--- a/RegistrationManager/include/RegistrationManager/RegistrationManager.h
+++ b/RegistrationManager/include/RegistrationManager/RegistrationManager.h
@@ -22,6 +22,7 @@
 #include <AVSCommon/SDKInterfaces/AuthDelegateInterface.h>
 #include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 
 #include "RegistrationManager/CustomerDataManager.h"
 #include "RegistrationManager/RegistrationObserverInterface.h"
@@ -43,11 +44,13 @@ public:
      * @param directiveSequencer Object used to clear directives during logout process.
      * @param connectionManager Connection manager must be disabled during customer logout.
      * @param dataManager Object that manages customer data, which must be cleared during logout.
+     * @param metricRecorder Object with which metrics are logged.
      */
     RegistrationManager(
         std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface> directiveSequencer,
         std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
-        std::shared_ptr<CustomerDataManager> dataManager);
+        std::shared_ptr<CustomerDataManager> dataManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /**
      * RegistrationManager destructor
@@ -93,6 +96,9 @@ private:
 
     // Observers
     std::unordered_set<std::shared_ptr<RegistrationObserverInterface> > m_observers;
+
+    /// The recorder used to log metrics.
+    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 };
 
 }  // namespace registrationManager
diff --git a/RegistrationManager/src/RegistrationManager.cpp b/RegistrationManager/src/RegistrationManager.cpp
index 16b38055..db8d7694 100644
--- a/RegistrationManager/src/RegistrationManager.cpp
+++ b/RegistrationManager/src/RegistrationManager.cpp
@@ -17,10 +17,18 @@
 
 #include "AVSCommon/Utils/Logger/Logger.h"
 #include "RegistrationManager/CustomerDataManager.h"
+#include <AVSCommon/Utils/Metrics/DataPointCounterBuilder.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("RegistrationManager");
 
+/// The metric source prefix string.
+static const std::string METRIC_SOURCE_PREFIX = "REGISTRATION_MANAGER-";
+
+/// The logout occurred metric string.
+static const std::string LOGOUT_OCCURRED = "LOGOUT_OCCURRED";
+
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
@@ -31,21 +39,48 @@ static const std::string TAG("RegistrationManager");
 namespace alexaClientSDK {
 namespace registrationManager {
 
+using namespace avsCommon::utils::metrics;
+
+/**
+ * Submits a logout occurred metric to the metric recorder.
+ * @param metricRecorder - The @c MetricRecorderInterface pointer.
+ */
+static void submitLogoutMetric(const std::shared_ptr<MetricRecorderInterface>& metricRecorder) {
+    if (!metricRecorder) {
+        return;
+    }
+
+    auto metricEvent = MetricEventBuilder{}
+                           .setActivityName(METRIC_SOURCE_PREFIX + LOGOUT_OCCURRED)
+                           .addDataPoint(DataPointCounterBuilder{}.setName(LOGOUT_OCCURRED).increment(1).build())
+                           .build();
+
+    if (!metricEvent) {
+        ACSDK_ERROR(LX("submitLogoutMetricFailed").d("reason", "null metric event"));
+        return;
+    }
+
+    recordMetric(metricRecorder, metricEvent);
+}
+
 void RegistrationManager::logout() {
     ACSDK_DEBUG(LX("logout"));
     m_directiveSequencer->disable();
     m_connectionManager->disable();
     m_dataManager->clearData();
     notifyObservers();
+    submitLogoutMetric(m_metricRecorder);
 }
 
 RegistrationManager::RegistrationManager(
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface> directiveSequencer,
     std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
-    std::shared_ptr<CustomerDataManager> dataManager) :
+    std::shared_ptr<CustomerDataManager> dataManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) :
         m_directiveSequencer{directiveSequencer},
         m_connectionManager{connectionManager},
-        m_dataManager{dataManager} {
+        m_dataManager{dataManager},
+        m_metricRecorder{metricRecorder} {
     if (!directiveSequencer) {
         ACSDK_ERROR(LX("RegistrationManagerFailed").m("Invalid directiveSequencer."));
     }
diff --git a/RegistrationManager/test/RegistrationManagerTest.cpp b/RegistrationManager/test/RegistrationManagerTest.cpp
index d3958942..07efa4b9 100644
--- a/RegistrationManager/test/RegistrationManagerTest.cpp
+++ b/RegistrationManager/test/RegistrationManagerTest.cpp
@@ -55,7 +55,7 @@ protected:
         m_dataManager = std::make_shared<CustomerDataManager>();
         m_dataHandler = avsCommon::utils::memory::make_unique<MockCustomerDataHandler>(m_dataManager);
         m_registrationManager.reset(
-            new RegistrationManager(m_directiveSequencer, m_avsConnectionManager, m_dataManager));
+            new RegistrationManager(m_directiveSequencer, m_avsConnectionManager, m_dataManager, nullptr));
         m_registrationObserver = std::make_shared<MockRegistrationObserver>();
         m_registrationManager->addObserver(m_registrationObserver);
     }
diff --git a/SampleApp/include/SampleApp/InteractionManager.h b/SampleApp/include/SampleApp/InteractionManager.h
index 9eba0869..595fabfe 100644
--- a/SampleApp/include/SampleApp/InteractionManager.h
+++ b/SampleApp/include/SampleApp/InteractionManager.h
@@ -422,7 +422,7 @@ public:
     /**
      * CallStateObserverInterface methods
      */
-    void onCallStateChange(CallState newState) override;
+    void onCallStateChange(CallState newState, const CallDisplayInfo& displayInfo) override;
 
 #ifdef ENABLE_PCC
     /**
diff --git a/SampleApp/src/InteractionManager.cpp b/SampleApp/src/InteractionManager.cpp
index 5b901b66..e6f52c66 100644
--- a/SampleApp/src/InteractionManager.cpp
+++ b/SampleApp/src/InteractionManager.cpp
@@ -593,7 +593,7 @@ void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
     });
 }
 
-void InteractionManager::onCallStateChange(CallState state) {
+void InteractionManager::onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) {
     m_executor.submit([this, state]() {
         if (CallState::CALL_CONNECTED == state) {
             if (!m_micWrapper->isStreaming()) {
diff --git a/Settings/include/Settings/CloudControlledSettingProtocol.h b/Settings/include/Settings/CloudControlledSettingProtocol.h
index 08e1bb67..762b88e1 100644
--- a/Settings/include/Settings/CloudControlledSettingProtocol.h
+++ b/Settings/include/Settings/CloudControlledSettingProtocol.h
@@ -16,6 +16,7 @@
 #include <memory>
 
 #include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 
 #include "Settings/SetSettingResult.h"
 #include "Settings/SettingEventMetadata.h"
@@ -42,13 +43,15 @@ public:
      * @param eventSender Object used to send events to AVS in order to report changes from the device.
      * @param settingStorage The setting storage object.
      * @param connectionManager An @c AVSConnectionManagerInterface instance to listen for connection status updates.
+     * @param metricRecorder An @c MetricRecorderInterface instance to log metrics.
      * @return A pointer to the new @c CloudControlledSettingProtocol object if it succeeds; @c nullptr otherwise.
      */
     static std::unique_ptr<CloudControlledSettingProtocol> create(
         const SettingEventMetadata& metadata,
         std::shared_ptr<SettingEventSenderInterface> eventSender,
         std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
-        std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager);
+        std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /**
      * Destructor.
diff --git a/Settings/include/Settings/DeviceControlledSettingProtocol.h b/Settings/include/Settings/DeviceControlledSettingProtocol.h
index a2d74f37..92857684 100644
--- a/Settings/include/Settings/DeviceControlledSettingProtocol.h
+++ b/Settings/include/Settings/DeviceControlledSettingProtocol.h
@@ -19,6 +19,7 @@
 #include <memory>
 
 #include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <AVSCommon/Utils/Threading/Executor.h>
 
 #include "Settings/SetSettingResult.h"
@@ -43,13 +44,15 @@ public:
      * @param eventSender Object used to send events to avs in order to report changes to the device.
      * @param settingStorage The setting storage object.
      * @param connectionManager An @c AVSConnectionManagerInterface instance to listen for connection status updates.
+     * @param metricRecorder An @c MetricRecorderInterface instance to log metrics.
      * @return A pointer to the new @c SharedAVSSettingProtocol object if it succeeds; @c nullptr otherwise.
      */
     static std::unique_ptr<DeviceControlledSettingProtocol> create(
         const SettingEventMetadata& metadata,
         std::shared_ptr<SettingEventSenderInterface> eventSender,
         std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
-        std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager);
+        std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /// @name SettingProtocolInterface methods.
     /// @{
diff --git a/Settings/include/Settings/Setting.h b/Settings/include/Settings/Setting.h
index f122d70d..c13a1421 100644
--- a/Settings/include/Settings/Setting.h
+++ b/Settings/include/Settings/Setting.h
@@ -187,7 +187,14 @@ template <typename ValueT>
 bool Setting<ValueT>::clearData(const ValueType& value) {
     std::lock_guard<std::mutex> lock{m_mutex};
     this->m_value = value;
-    return m_protocol->clearData();
+    // Clear customer's data before restoring the initial value
+    auto result = m_protocol->clearData();
+    if (result) {
+        // this->m_value (initial value) is restored
+        // as databaseValue.empty() == true
+        restore();
+    }
+    return result;
 }
 
 template <typename ValueT>
diff --git a/Settings/include/Settings/SharedAVSSettingProtocol.h b/Settings/include/Settings/SharedAVSSettingProtocol.h
index 46659c46..c7772623 100644
--- a/Settings/include/Settings/SharedAVSSettingProtocol.h
+++ b/Settings/include/Settings/SharedAVSSettingProtocol.h
@@ -23,6 +23,7 @@
 #include <utility>
 
 #include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <AVSCommon/Utils/Threading/Executor.h>
 
 #include "Settings/SetSettingResult.h"
@@ -50,6 +51,7 @@ public:
      * @param eventSender Object used to send events to avs in order to report changes to the device.
      * @param settingStorage The setting storage object.
      * @param connectionManager An @c AVSConnectionManagerInterface instance to listen for connection status updates.
+     * @param metricRecorder The @c MetricRecorderInterface to record metrics.
      * @param isDefaultCloudAuthoritative Indicates if the default value for the setting should be cloud
      * authoritative or not.  If it is, for the first time when the setting is created, the default value of the
      * setting will be sent to AVS using a report event.  If it is not cloud authoritative, then the default value of
@@ -61,6 +63,7 @@ public:
         std::shared_ptr<SettingEventSenderInterface> eventSender,
         std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
         std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
         bool isDefaultCloudAuthoritative = false);
 
     /// @name SettingProtocolInterface methods.
@@ -121,6 +124,7 @@ private:
      * @param eventSender Object used to send events to avs in order to report changes to the device.
      * @param settingStorage The setting storage object.
      * @param connectionManager An @c AVSConnectionManagerInterface instance to listen for connection status updates.
+     * @param metricRecorder The @c MetricRecorderInterface to record metrics.
      * @param isDefaultCloudAuthoritative Indicates if the default value for the setting should be cloud
      * authoritative or not.  If it is, for the first time when the setting is created, the default value of the
      * setting will be sent to AVS using a report event.  If it is not cloud authoritative, then the default value of
@@ -131,6 +135,7 @@ private:
         std::shared_ptr<SettingEventSenderInterface> eventSender,
         std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
         std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
         bool isDefaultCloudAuthoritative);
 
     /**
@@ -159,6 +164,8 @@ private:
     /// The change request to be applied. This value is null if there is no task scheduled to process the request.
     std::unique_ptr<Request> m_pendingRequest;
 
+    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+
     /// The mutex used to serialize access to @c m_pendingRequest
     std::mutex m_requestLock;
 
diff --git a/Settings/src/CloudControlledSettingProtocol.cpp b/Settings/src/CloudControlledSettingProtocol.cpp
index 044978c9..0205b1fa 100644
--- a/Settings/src/CloudControlledSettingProtocol.cpp
+++ b/Settings/src/CloudControlledSettingProtocol.cpp
@@ -34,9 +34,10 @@ std::unique_ptr<CloudControlledSettingProtocol> CloudControlledSettingProtocol::
     const SettingEventMetadata& metadata,
     std::shared_ptr<SettingEventSenderInterface> eventSender,
     std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
-    std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager) {
-    auto sharedProtocol =
-        SharedAVSSettingProtocol::create(metadata, eventSender, settingStorage, connectionManager, true);
+    std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
+    auto sharedProtocol = SharedAVSSettingProtocol::create(
+        metadata, eventSender, settingStorage, connectionManager, metricRecorder, true);
     if (!sharedProtocol) {
         ACSDK_ERROR(LX("createFailed").d("reason", "cannot create shared Protocol"));
         return nullptr;
diff --git a/Settings/src/DeviceControlledSettingProtocol.cpp b/Settings/src/DeviceControlledSettingProtocol.cpp
index 20639977..e0406c7b 100644
--- a/Settings/src/DeviceControlledSettingProtocol.cpp
+++ b/Settings/src/DeviceControlledSettingProtocol.cpp
@@ -34,8 +34,10 @@ std::unique_ptr<DeviceControlledSettingProtocol> DeviceControlledSettingProtocol
     const SettingEventMetadata& metadata,
     std::shared_ptr<SettingEventSenderInterface> eventSender,
     std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
-    std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager) {
-    auto sharedProtocol = SharedAVSSettingProtocol::create(metadata, eventSender, settingStorage, connectionManager);
+    std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
+    auto sharedProtocol =
+        SharedAVSSettingProtocol::create(metadata, eventSender, settingStorage, connectionManager, metricRecorder);
     if (!sharedProtocol) {
         ACSDK_ERROR(LX("createFailed").d("reason", "cannotCreateProtocolImplementation"));
         return nullptr;
diff --git a/Settings/src/SharedAVSSettingProtocol.cpp b/Settings/src/SharedAVSSettingProtocol.cpp
index 41715671..3ff0f55c 100644
--- a/Settings/src/SharedAVSSettingProtocol.cpp
+++ b/Settings/src/SharedAVSSettingProtocol.cpp
@@ -14,6 +14,9 @@
  */
 
 #include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Metrics/DataPointCounterBuilder.h>
+#include <AVSCommon/Utils/Metrics/DataPointStringBuilder.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
 
 #include "Settings/SharedAVSSettingProtocol.h"
 
@@ -30,9 +33,60 @@ static const std::string TAG("SharedAVSSettingProtocol");
 namespace alexaClientSDK {
 namespace settings {
 
+using namespace avsCommon::utils::metrics;
+
 /// Protocol should call apply change with an empty string when no value is found in the database.
 static const std::string INVALID_VALUE = "";
 
+/// The metrics source string.
+static const std::string METRIC_SOURCE_PREFIX = "SETTINGS-";
+
+/// The local change metric string.
+static const std::string LOCAL_CHANGE_METRIC = "LOCAL_CHANGE";
+
+/// The local change failed metric string.
+static const std::string LOCAL_CHANGE_FAILED_METRIC = "LOCAL_CHANGE_FAILED";
+
+/// The AVS change metric string.
+static const std::string AVS_CHANGE_METRIC = "AVS_CHANGE";
+
+/// The local change failed metric string.
+static const std::string AVS_CHANGE_FAILED_METRIC = "AVS_CHANGE_FAILED";
+
+/// The setting key metric string.
+static const std::string SETTING_KEY = "SETTING_KEY";
+
+/**
+ * Submits a counter metric with the passed in event name
+ * @note: This function returns immediately if metricRecorder is null.
+ *
+ * @param metricRecorder The @c MetricRecorder instance used to record the metric.
+ * @param eventName The event name string.
+ * @param count The count to increment the datapoint with.
+ */
+static void submitMetric(
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+    const std::string& eventName,
+    const std::string& settingsKey,
+    uint64_t count) {
+    if (!metricRecorder) {
+        return;
+    }
+
+    auto metricEvent = MetricEventBuilder{}
+                           .setActivityName(METRIC_SOURCE_PREFIX + eventName)
+                           .addDataPoint(DataPointCounterBuilder{}.setName(eventName).increment(count).build())
+                           .addDataPoint(DataPointStringBuilder{}.setName(SETTING_KEY).setValue(settingsKey).build())
+                           .build();
+
+    if (!metricEvent) {
+        ACSDK_ERROR(LX("submitMetricFailed").d("reason", "invalid metric event"));
+        return;
+    }
+
+    recordMetric(metricRecorder, metricEvent);
+}
+
 SharedAVSSettingProtocol::Request::Request(
     ApplyChangeFunction applyFn,
     RevertChangeFunction revertFn,
@@ -47,6 +101,7 @@ std::unique_ptr<SharedAVSSettingProtocol> SharedAVSSettingProtocol::create(
     std::shared_ptr<SettingEventSenderInterface> eventSender,
     std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
     std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
     bool isDefaultCloudAuthoritative) {
     ACSDK_DEBUG5(LX(__func__).d("settingName", metadata.settingName));
 
@@ -68,7 +123,7 @@ std::unique_ptr<SharedAVSSettingProtocol> SharedAVSSettingProtocol::create(
     std::string settingKey = metadata.eventNamespace + "::" + metadata.settingName;
 
     return std::unique_ptr<SharedAVSSettingProtocol>(new SharedAVSSettingProtocol(
-        settingKey, eventSender, settingStorage, connectionManager, isDefaultCloudAuthoritative));
+        settingKey, eventSender, settingStorage, connectionManager, metricRecorder, isDefaultCloudAuthoritative));
 }
 
 SharedAVSSettingProtocol::~SharedAVSSettingProtocol() {
@@ -114,6 +169,7 @@ SetSettingResult SharedAVSSettingProtocol::localChange(
             if (!ok) {
                 ACSDK_ERROR(LX("localChangeFailed").d("reason", "cannotApplyChange"));
                 request->notifyObservers(SettingNotifications::LOCAL_CHANGE_FAILED);
+                submitMetric(m_metricRecorder, LOCAL_CHANGE_FAILED_METRIC, m_key, 1);
                 return;
             }
 
@@ -121,10 +177,13 @@ SetSettingResult SharedAVSSettingProtocol::localChange(
                 ACSDK_ERROR(LX("localChangeFailed").d("reason", "cannotUpdateDatabase"));
                 request->revertChange();
                 request->notifyObservers(SettingNotifications::LOCAL_CHANGE_FAILED);
+                submitMetric(m_metricRecorder, LOCAL_CHANGE_FAILED_METRIC, m_key, 1);
                 return;
             }
 
             request->notifyObservers(SettingNotifications::LOCAL_CHANGE);
+            submitMetric(m_metricRecorder, LOCAL_CHANGE_METRIC, m_key, 1);
+            submitMetric(m_metricRecorder, LOCAL_CHANGE_FAILED_METRIC, m_key, 0);
 
             if (!this->m_eventSender->sendChangedEvent(value).get()) {
                 ACSDK_ERROR(LX("localChangeFailed").d("reason", "sendEventFailed"));
@@ -180,13 +239,17 @@ bool SharedAVSSettingProtocol::avsChange(
             if (!ok) {
                 ACSDK_ERROR(LX("avsChangeFailed").d("reason", "cannotApplyChange"));
                 request->notifyObservers(SettingNotifications::AVS_CHANGE_FAILED);
+                submitMetric(m_metricRecorder, AVS_CHANGE_FAILED_METRIC, m_key, 1);
             } else if (!this->m_storage->storeSetting(m_key, value, SettingStatus::AVS_CHANGE_IN_PROGRESS)) {
                 ACSDK_ERROR(LX("avsChangeFailed").d("reason", "cannotUpdateDatabaseValue"));
                 request->notifyObservers(SettingNotifications::AVS_CHANGE_FAILED);
                 value = request->revertChange();
+                submitMetric(m_metricRecorder, AVS_CHANGE_FAILED_METRIC, m_key, 1);
             } else {
                 request->notifyObservers(SettingNotifications::AVS_CHANGE);
+                submitMetric(m_metricRecorder, AVS_CHANGE_FAILED_METRIC, m_key, 0);
             }
+            submitMetric(m_metricRecorder, AVS_CHANGE_METRIC, m_key, 1);
 
             /// We need to send the report for failure or success case.
             if (!this->m_eventSender->sendReportEvent(value).get()) {
@@ -256,11 +319,13 @@ SharedAVSSettingProtocol::SharedAVSSettingProtocol(
     std::shared_ptr<SettingEventSenderInterface> eventSender,
     std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
     std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
     bool isDefaultCloudAuthoritative) :
         m_key{key},
         m_isDefaultCloudAuthoritative{isDefaultCloudAuthoritative},
         m_eventSender{eventSender},
-        m_storage{settingStorage} {
+        m_storage{settingStorage},
+        m_metricRecorder{metricRecorder} {
     m_connectionManager = connectionManager;
 
     m_connectionObserver = SettingConnectionObserver::create(
diff --git a/Settings/src/Types/LocaleWakeWordsSetting.cpp b/Settings/src/Types/LocaleWakeWordsSetting.cpp
index e71321c1..7129a51f 100644
--- a/Settings/src/Types/LocaleWakeWordsSetting.cpp
+++ b/Settings/src/Types/LocaleWakeWordsSetting.cpp
@@ -359,7 +359,14 @@ bool LocaleWakeWordsSetting::clearData(const DeviceLocales& locales) {
     m_pendingRequest.reset();
     m_localeStatus = SettingStatus::NOT_AVAILABLE;
     LocalesSetting::m_value = locales;
-    return m_storage->deleteSetting(LOCALE_KEY);
+    // Clear customer's data before restoring the initial value
+    auto result = m_storage->deleteSetting(LOCALE_KEY);
+    if (result) {
+        // As m_localeStatus == SettingStatus::NOT_AVAILABLE restoreInitialValue()
+        // calls LocalesSetting::get() which returns LocalesSetting::m_value
+        restoreInitialValue();
+    }
+    return result;
 }
 
 bool LocaleWakeWordsSetting::clearData(const WakeWords& wakeWords) {
@@ -368,7 +375,14 @@ bool LocaleWakeWordsSetting::clearData(const WakeWords& wakeWords) {
     m_pendingRequest.reset();
     m_wakeWordsStatus = SettingStatus::NOT_AVAILABLE;
     WakeWordsSetting::m_value = wakeWords;
-    return m_storage->deleteSetting(WAKE_WORDS_KEY);
+    // Clear customer's data before restoring the initial value
+    auto result = m_storage->deleteSetting(WAKE_WORDS_KEY);;
+    if (result) {
+        // As m_wakeWordsStatus == SettingStatus::NOT_AVAILABLE restoreInitialValue()
+        // calls WakeWordsSetting::get() which returns WakeWordsSetting::m_value
+        restoreInitialValue();
+    }
+    return result;
 }
 
 void LocaleWakeWordsSetting::restoreInitialValue() {
diff --git a/Settings/test/CMakeLists.txt b/Settings/test/CMakeLists.txt
index d7bba115..09c0e979 100644
--- a/Settings/test/CMakeLists.txt
+++ b/Settings/test/CMakeLists.txt
@@ -12,6 +12,7 @@ if (BUILD_TESTING)
         "${AVSCommon_SOURCE_DIR}/AVS/test"
         "${AVSCommon_SOURCE_DIR}/Utils/include"
         "${AVSCommon_SOURCE_DIR}/SDKInterfaces/test"
+        "${AVSCommon_SOURCE_DIR}/Utils/test"
         "${CertifiedSender_SOURCE_DIR}/test")
 
     set(TEST_FOLDER "${DeviceSettings_SOURCE_DIR}/test")
diff --git a/Settings/test/SharedAVSSettingProtocolTest.cpp b/Settings/test/SharedAVSSettingProtocolTest.cpp
index 4f841cce..b6aa5f87 100644
--- a/Settings/test/SharedAVSSettingProtocolTest.cpp
+++ b/Settings/test/SharedAVSSettingProtocolTest.cpp
@@ -20,6 +20,7 @@
 #include <gtest/gtest.h>
 
 #include <AVSCommon/SDKInterfaces/MockAVSConnectionManager.h>
+#include <AVSCommon/Utils/Metrics/MockMetricRecorder.h>
 #include <AVSCommon/Utils/WaitEvent.h>
 #include <Settings/SharedAVSSettingProtocol.h>
 #include <Settings/SettingEventMetadata.h>
@@ -34,8 +35,9 @@ namespace test {
 
 using namespace testing;
 using namespace storage::test;
-using namespace avsCommon::utils;
 using namespace avsCommon::sdkInterfaces::test;
+using namespace avsCommon::utils;
+using namespace avsCommon::utils::metrics::test;
 
 /// A dummy setting metadata.
 const SettingEventMetadata METADATA = {"namespace", "ChangedName", "ReportName", "setting"};
@@ -102,6 +104,9 @@ protected:
     /// Pointer to a mock protocol.
     std::unique_ptr<SharedAVSSettingProtocol> m_protocol;
 
+    /// Mock Metric Recorder.
+    std::shared_ptr<MockMetricRecorder> m_metricRecorder;
+
     /// Mock callbacks.
     StrictMock<MockCallbacks> m_callbacksMock;
 
@@ -113,7 +118,9 @@ void SharedAVSSettingProtocolTest::SetUp() {
     m_senderMock = std::make_shared<StrictMock<MockSettingEventSender>>();
     m_storageMock = std::make_shared<StrictMock<MockDeviceSettingStorage>>();
     m_mockConnectionManager = std::make_shared<NiceMock<MockAVSConnectionManager>>();
-    m_protocol = SharedAVSSettingProtocol::create(METADATA, m_senderMock, m_storageMock, m_mockConnectionManager);
+    m_metricRecorder = std::make_shared<NiceMock<MockMetricRecorder>>();
+    m_protocol = SharedAVSSettingProtocol::create(
+        METADATA, m_senderMock, m_storageMock, m_mockConnectionManager, m_metricRecorder);
 }
 
 void SharedAVSSettingProtocolTest::modifySetting(std::string value, bool isLocal) {
@@ -230,12 +237,14 @@ void SharedAVSSettingProtocolTest::testMultipleChanges(bool isLocal) {
 
 /// Test create with null event sender.
 TEST_F(SharedAVSSettingProtocolTest, test_nullEventSender) {
-    ASSERT_FALSE(SharedAVSSettingProtocol::create(METADATA, nullptr, m_storageMock, m_mockConnectionManager));
+    ASSERT_FALSE(
+        SharedAVSSettingProtocol::create(METADATA, nullptr, m_storageMock, m_mockConnectionManager, m_metricRecorder));
 }
 
 /// Test create with null storage.
 TEST_F(SharedAVSSettingProtocolTest, test_nullStorage) {
-    ASSERT_FALSE(SharedAVSSettingProtocol::create(METADATA, m_senderMock, nullptr, m_mockConnectionManager));
+    ASSERT_FALSE(
+        SharedAVSSettingProtocol::create(METADATA, m_senderMock, nullptr, m_mockConnectionManager, m_metricRecorder));
 }
 
 /// Test restore when value is not available in the database.
@@ -285,8 +294,8 @@ TEST_F(SharedAVSSettingProtocolTest, test_restoreValueNotAvailableCloudAuthorita
         return retPromise.get_future();
     }));
 
-    auto protocol =
-        SharedAVSSettingProtocol::create(METADATA, m_senderMock, m_storageMock, m_mockConnectionManager, true);
+    auto protocol = SharedAVSSettingProtocol::create(
+        METADATA, m_senderMock, m_storageMock, m_mockConnectionManager, m_metricRecorder, true);
 
     protocol->restoreValue(
         std::bind(&MockCallbacks::applyDbChange, &m_callbacksMock, std::placeholders::_1),
diff --git a/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerBuilder.h b/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerBuilder.h
index bf1daa66..14f53d2b 100644
--- a/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerBuilder.h
+++ b/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerBuilder.h
@@ -25,6 +25,7 @@
 #include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/SystemTimeZoneInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h>
 #include <RegistrationManager/CustomerDataManager.h>
 #include <Settings/CloudControlledSettingProtocol.h>
@@ -57,6 +58,7 @@ public:
      * DoNotDisturbSetting is managed differently than other settings in the SDK (ACSDK-2279). This is a legacy
      * anti-pattern, and other CAs should be injected with the DeviceSettingsManager (as opposed to the
      * DeviceSettingsManager being injected with the DND CA, as seen here).
+     * @param metricRecorder The @c MetricRecorderInterface instance used to log metrics.
      * @param systemTimezone Optional parameter responsible for validating / applying timezone changes system wide.
      */
     static std::shared_ptr<settings::DeviceSettingsManager> createDeviceSettingsManager(
@@ -66,6 +68,7 @@ public:
         std::shared_ptr<registrationManager::CustomerDataManager> dataManager,
         std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface> localeAssetsManager,
         std::shared_ptr<capabilityAgents::doNotDisturb::DoNotDisturbCapabilityAgent> doNotDisturbCapabilityAgent,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
         std::shared_ptr<avsCommon::sdkInterfaces::SystemTimeZoneInterface> systemTimezone = nullptr);
 
     /**
@@ -75,12 +78,14 @@ public:
      * @param messageSender Sender used to send events related to this setting changes.
      * @param connectionManager The ACL connection manager.
      * @param dataManager A dataManager object that will track the CustomerDataHandler.
+     * @param metricRecorder The @c MetricRecorderInterface instance used to log metrics.
      */
     DeviceSettingsManagerBuilder(
         std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingStorage,
         std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
         std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
-        std::shared_ptr<registrationManager::CustomerDataManager> dataManager);
+        std::shared_ptr<registrationManager::CustomerDataManager> dataManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /**
      * Configures do not disturb setting.
@@ -205,6 +210,9 @@ private:
     /// The dataManager object that will track the CustomerDataHandler.
     std::shared_ptr<registrationManager::CustomerDataManager> m_dataManager;
 
+    /// The Metric Recorder object to log metrics.
+    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+
     /// Flag that indicates if there was any configuration error.
     bool m_foundError;
 };
diff --git a/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerComponent.h b/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerComponent.h
index 7473338b..db2cbf24 100644
--- a/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerComponent.h
+++ b/applications/acsdkDefaultDeviceSettingsManager/include/acsdkDeviceSettingsManager/DeviceSettingsManagerComponent.h
@@ -24,6 +24,7 @@
 #include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/SystemTimeZoneInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h>
 #include <RegistrationManager/CustomerDataManager.h>
 #include <Settings/DeviceSettingsManager.h>
@@ -42,6 +43,7 @@ using DeviceSettingsManagerComponent = acsdkManufactory::Component<
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::SystemTimeZoneInterface>>,
+    acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<capabilityAgents::doNotDisturb::DoNotDisturbCapabilityAgent>>,
     acsdkManufactory::Import<std::shared_ptr<registrationManager::CustomerDataManager>>,
     acsdkManufactory::Import<std::shared_ptr<settings::storage::DeviceSettingStorageInterface>>>;
diff --git a/applications/acsdkDefaultDeviceSettingsManager/src/DeviceSettingsManagerBuilder.cpp b/applications/acsdkDefaultDeviceSettingsManager/src/DeviceSettingsManagerBuilder.cpp
index eb5d9b6d..ccbc1d7a 100644
--- a/applications/acsdkDefaultDeviceSettingsManager/src/DeviceSettingsManagerBuilder.cpp
+++ b/applications/acsdkDefaultDeviceSettingsManager/src/DeviceSettingsManagerBuilder.cpp
@@ -71,6 +71,7 @@ std::shared_ptr<settings::DeviceSettingsManager> DeviceSettingsManagerBuilder::c
     std::shared_ptr<registrationManager::CustomerDataManager> dataManager,
     std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface> localeAssetsManager,
     std::shared_ptr<capabilityAgents::doNotDisturb::DoNotDisturbCapabilityAgent> doNotDisturbCapabilityAgent,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
     std::shared_ptr<avsCommon::sdkInterfaces::SystemTimeZoneInterface> systemTimezone) {
     if (!settingStorage || !messageSender || !connectionManager || !dataManager || !localeAssetsManager ||
         !doNotDisturbCapabilityAgent) {
@@ -84,7 +85,8 @@ std::shared_ptr<settings::DeviceSettingsManager> DeviceSettingsManagerBuilder::c
         return nullptr;
     }
 
-    DeviceSettingsManagerBuilder settingsManagerBuilder{settingStorage, messageSender, connectionManager, dataManager};
+    DeviceSettingsManagerBuilder settingsManagerBuilder{
+        settingStorage, messageSender, connectionManager, dataManager, metricRecorder};
     settingsManagerBuilder.withDoNotDisturbSetting(doNotDisturbCapabilityAgent)
         .withAlarmVolumeRampSetting()
         .withWakeWordConfirmationSetting()
@@ -107,11 +109,13 @@ DeviceSettingsManagerBuilder::DeviceSettingsManagerBuilder(
     std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
     std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
     std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface> connectionManager,
-    std::shared_ptr<registrationManager::CustomerDataManager> dataManager) :
+    std::shared_ptr<registrationManager::CustomerDataManager> dataManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) :
         m_settingStorage{settingStorage},
         m_messageSender{messageSender},
         m_connectionManager{connectionManager},
         m_dataManager{dataManager},
+        m_metricRecorder{metricRecorder},
         m_foundError{false} {
     m_foundError =
         !(checkPointer(settingStorage, "settingStorage") && checkPointer(messageSender, "messageSender") &&
@@ -250,7 +254,8 @@ DeviceSettingsManagerBuilder& DeviceSettingsManagerBuilder::withSynchronizedSett
     const ValueType<index>& defaultValue,
     std::function<bool(const ValueType<index>&)> applyFn) {
     auto eventSender = SettingEventSender::create(metadata, m_connectionManager);
-    auto protocol = ProtocolT::create(metadata, std::move(eventSender), m_settingStorage, m_connectionManager);
+    auto protocol =
+        ProtocolT::create(metadata, std::move(eventSender), m_settingStorage, m_connectionManager, m_metricRecorder);
     auto setting = Setting<ValueType<index>>::create(defaultValue, std::move(protocol), applyFn);
 
     if (!setting) {
diff --git a/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h b/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h
index 3af79f79..aaacdb28 100644
--- a/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h
+++ b/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h
@@ -361,6 +361,32 @@ private:
         acsdkAlertsInterfaces::AlertObserverInterface::State state,
         const std::string& reason);
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    void executeOnAlertCreated(
+        const std::string& alertToken,
+        const std::string& jsonPayload);
+
+    /**
+     * A handler function which will be called by our internal executor when an alert is deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    void executeOnAlertDeleted(
+        const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to add an alert observer.
      *
@@ -389,6 +415,21 @@ private:
         acsdkAlertsInterfaces::AlertObserverInterface::State state,
         const std::string& reason = "");
 
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of detailed alert info.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     * @param jsonInfo The detailed JSON info. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertCreatedObservers(const std::string& alertToken, const std::string& jsonInfo);
+
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of an alert deleted.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertDeletedObservers(const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to remove all alerts currently being managed.
      */
diff --git a/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp b/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp
index 53ef37bb..39dfdb2d 100644
--- a/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp
+++ b/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp
@@ -79,6 +79,9 @@ static const std::string ALERTS_CAPABILITY_INTERFACE_VERSION = "1.5";
 /// The value for Type which we need for json parsing.
 static const std::string KEY_TYPE = "type";
 
+/// The value for Label which we need for json parsing.
+static const std::string KEY_LABEL = "label";
+
 // ==== Directives ===
 
 /// The value of the SetAlert Directive.
@@ -829,6 +832,27 @@ bool AlertsCapabilityAgent::handleSetAlert(
 
     updateContextManager();
 
+    Document document( rapidjson::kObjectType );
+    document.AddMember("time", parsedAlert->getScheduledTime_ISO_8601(), document.GetAllocator());
+    document.AddMember("type", parsedAlert->getTypeName(), document.GetAllocator());
+    std::string label;
+    if (!retrieveValue(payload, KEY_LABEL, &label)) {
+        document.AddMember("label", "", document.GetAllocator());
+    } else {
+        document.AddMember("label", label, document.GetAllocator());
+    }
+    // build the json state string
+    rapidjson::StringBuffer buffer;
+    rapidjson::Writer<rapidjson::StringBuffer> writer( buffer );
+
+    if (!document.Accept( writer )) {
+        ACSDK_ERROR(LX("failedToWriteJsonDocument").m("Alert DetailedInfo not sent"));
+    } else {
+        std::string payload = buffer.GetString();
+        std::string token = parsedAlert->getToken();
+        m_executor.submit([this, token, payload]() { executeOnAlertCreated( token, payload); });
+    }
+
     return true;
 }
 
@@ -850,6 +874,9 @@ bool AlertsCapabilityAgent::handleDeleteAlert(
     submitMetric(m_metricRecorder, "failedToDeleteAlert", 0);
     updateContextManager();
 
+    std::string token = *alertToken;
+    m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
+
     return true;
 }
 
@@ -879,6 +906,8 @@ bool AlertsCapabilityAgent::handleDeleteAlerts(
         if (!convertToValue(tokenArray[i], &token)) {
             ACSDK_WARN(LX("handleDeleteAlertsFailed").d("reason", "invalid token in payload"));
             continue;
+        } else {
+            m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
         }
         alertTokens.push_back(token);
     }
@@ -1266,6 +1295,14 @@ void AlertsCapabilityAgent::executeOnAlertStateChange(
     });
 }
 
+void AlertsCapabilityAgent::executeOnAlertCreated(const std::string& alertToken, const std::string& payload){
+    m_executor.submit([this, alertToken, payload]() { executeNotifyAlertCreatedObservers(alertToken, payload); });
+}
+
+void AlertsCapabilityAgent::executeOnAlertDeleted(const std::string& alertToken){
+    m_executor.submit([this, alertToken]() { executeNotifyAlertDeletedObservers(alertToken); });
+}
+
 void AlertsCapabilityAgent::executeAddObserver(std::shared_ptr<AlertObserverInterface> observer) {
     ACSDK_DEBUG1(LX("executeAddObserver").d("observer", observer.get()));
     m_observers.insert(observer);
@@ -1291,6 +1328,23 @@ void AlertsCapabilityAgent::executeNotifyObservers(
     }
 }
 
+void AlertsCapabilityAgent::executeNotifyAlertCreatedObservers(
+    const std::string& alertToken,
+    const std::string& payload) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertCreatedObservers").d("alertToken", alertToken).sensitive("payload", payload));
+    for (auto observer : m_observers) {
+        observer->onAlertCreated(alertToken, payload);
+    }
+}
+
+void AlertsCapabilityAgent::executeNotifyAlertDeletedObservers(
+    const std::string& alertToken) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertDeletedObservers").d("alertToken", alertToken));
+    for (auto observer : m_observers) {
+        observer->onAlertDeleted(alertToken);
+    }
+}
+
 void AlertsCapabilityAgent::executeRemoveAllAlerts() {
     ACSDK_DEBUG1(LX("executeRemoveAllAlerts"));
     m_alertScheduler.clearData();
diff --git a/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h b/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h
index 2e47a530..bf564140 100644
--- a/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h
+++ b/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h
@@ -73,6 +73,29 @@ public:
         State state,
         const std::string& reason = "") = 0;
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    virtual void onAlertCreated(const std::string& alertToken, const std::string& detailedInfo) {};
+
+    /**
+     * A callback function to notify an object that an alert has been deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    virtual void onAlertDeleted(const std::string& alertToken) {};
+
     /**
      * Convert a @c State to a @c std::string.
      *
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DNDSettingProtocol.h b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DNDSettingProtocol.h
index 9ecd7fbe..75a37fdf 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DNDSettingProtocol.h
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DNDSettingProtocol.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <utility>
 
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <AVSCommon/Utils/Threading/Executor.h>
 #include <Settings/SetSettingResult.h>
 #include <Settings/SettingEventMetadata.h>
@@ -45,12 +46,14 @@ public:
      * @param metadata The setting metadata used to generate a unique database key.
      * @param eventSender Object used to send events to avs in order to report changes to the device.
      * @param settingStorage The setting storage object.
+     * @param metricRecorder The @c MetricRecorderInterface instance to record metrics.
      * @return A pointer to the new @c DNDSettingProtocol object if it succeeds; @c nullptr otherwise.
      */
     static std::unique_ptr<DNDSettingProtocol> create(
         const settings::SettingEventMetadata& metadata,
         std::shared_ptr<settings::SettingEventSenderInterface> eventSender,
-        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingStorage);
+        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingStorage,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /// @name SettingProtocolInterface methods.
     /// @{
@@ -80,11 +83,13 @@ private:
      * @param settingKey The setting key used to access the setting storage.
      * @param eventSender Object used to send events to avs in order to report changes to the device.
      * @param settingStorage The setting storage object.
+     * @param metricRecorder The @c MetricRecorderInterface instance to record metrics.
      */
     DNDSettingProtocol(
         const std::string& settingKey,
         std::shared_ptr<settings::SettingEventSenderInterface> eventSender,
-        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingStorage);
+        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingStorage,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /// The setting key used to access the setting storage.
     const std::string m_key;
@@ -95,6 +100,9 @@ private:
     /// The setting storage object.
     std::shared_ptr<settings::storage::DeviceSettingStorageInterface> m_storage;
 
+    /// The @c MetricRecorderInterface instance to record metrics.
+    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+
     /// Executor used to handle events in sequence.
     avsCommon::utils::threading::Executor m_executor;
 };
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h
index f0317d2d..2c3188fa 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h
@@ -32,6 +32,7 @@
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/DefaultEndpointAnnotation.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesRegistrarInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <AVSCommon/Utils/RequiresShutdown.h>
 #include <AVSCommon/Utils/Threading/Executor.h>
 #include <Settings/DeviceSettingsManager.h>
@@ -76,6 +77,7 @@ public:
      * @param endpointCapabilitiesRegistrar The object with which to register this AudioPlayer's capabilities for the
      * default endpoint.
      * @param connectionManager The object to notify this CA of connection status changes.
+     * @param metricRecorder The @c MetricRecorderInterface instance to record metrics.
      * @return A new instance of @c DoNotDisturbCapabilityAgent on success, @c nullptr otherwise.
      */
     static std::shared_ptr<DoNotDisturbCapabilityAgent> createDoNotDisturbCapabilityAgent(
@@ -89,7 +91,8 @@ public:
             alexaClientSDK::avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface>&
             endpointCapabilitiesRegistrar,
         const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::AVSConnectionManagerInterface>&
-            connectionManager);
+            connectionManager,
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /**
      * Factory method to create a capability agent instance.
@@ -184,7 +187,9 @@ private:
         const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>&
             exceptionSender,
         const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::AVSConnectionManagerInterface>&
-            connectionManager = nullptr);
+            connectionManager = nullptr,
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder =
+            nullptr);
 
     /**
      * Method to initialize the new instance of the capability agent.
@@ -192,7 +197,9 @@ private:
      * @param settingsStorage The storage interface that will be used to store device settings.
      * @return True on success, false otherwise.
      */
-    bool initialize(std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+    bool initialize(
+        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
     /**
      * Sends a DND event to the AVS.
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbComponent.h b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbComponent.h
index 6ba6ebd3..77d4ae94 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbComponent.h
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbComponent.h
@@ -26,6 +26,7 @@
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/DefaultEndpointAnnotation.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesRegistrarInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 
 #include "acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h"
 
@@ -40,6 +41,7 @@ using DoNotDisturbComponent = acsdkManufactory::Component<
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>>,
+    acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
     acsdkManufactory::Import<acsdkManufactory::Annotated<
         avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
index 0145b32d..82222807 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
@@ -16,6 +16,9 @@
 #include <functional>
 
 #include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/DataPointCounterBuilder.h>
+#include <AVSCommon/Utils/Metrics/DataPointStringBuilder.h>
 
 #include "acsdkDoNotDisturb/DNDSettingProtocol.h"
 
@@ -33,15 +36,66 @@ namespace alexaClientSDK {
 namespace capabilityAgents {
 namespace doNotDisturb {
 
+using namespace avsCommon::utils::metrics;
 using namespace settings;
 
 /// String to designate invalid value for the DND setting. NOTE: Valid values are "true" and "false".
 static const std::string INVALID_VALUE = "";
 
+/// The metrics source string.
+static const std::string METRIC_SOURCE_PREFIX = "SETTINGS-";
+
+/// The local change metric string.
+static const std::string LOCAL_CHANGE_METRIC = "LOCAL_CHANGE";
+
+/// The local change failed metric string.
+static const std::string LOCAL_CHANGE_FAILED_METRIC = "LOCAL_CHANGE_FAILED";
+
+/// The AVS change metric string.
+static const std::string AVS_CHANGE_METRIC = "AVS_CHANGE";
+
+/// The local change failed metric string.
+static const std::string AVS_CHANGE_FAILED_METRIC = "AVS_CHANGE_FAILED";
+
+/// The setting key metric string.
+static const std::string SETTING_KEY = "SETTING_KEY";
+
+/**
+ * Submits a counter metric with the passed in event name
+ * @note: This function returns immediately if metricRecorder is null.
+ *
+ * @param metricRecorder The @c MetricRecorder instance used to record the metric.
+ * @param eventName The event name string.
+ * @param count The count to increment the datapoint with.
+ */
+static void submitMetric(
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+    const std::string& eventName,
+    const std::string& settingsKey,
+    uint64_t count) {
+    if (!metricRecorder) {
+        return;
+    }
+
+    auto metricEvent = MetricEventBuilder{}
+                           .setActivityName(METRIC_SOURCE_PREFIX + eventName)
+                           .addDataPoint(DataPointCounterBuilder{}.setName(eventName).increment(count).build())
+                           .addDataPoint(DataPointStringBuilder{}.setName(SETTING_KEY).setValue(settingsKey).build())
+                           .build();
+
+    if (!metricEvent) {
+        ACSDK_ERROR(LX("submitMetricFailed").d("reason", "invalid metric event"));
+        return;
+    }
+
+    recordMetric(metricRecorder, metricEvent);
+}
+
 std::unique_ptr<DNDSettingProtocol> DNDSettingProtocol::create(
     const SettingEventMetadata& metadata,
     std::shared_ptr<SettingEventSenderInterface> eventSender,
-    std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage) {
+    std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
     ACSDK_DEBUG5(LX(__func__).d("settingName", metadata.settingName));
 
     if (!eventSender) {
@@ -56,7 +110,8 @@ std::unique_ptr<DNDSettingProtocol> DNDSettingProtocol::create(
 
     std::string settingKey = metadata.eventNamespace + "::" + metadata.settingName;
 
-    return std::unique_ptr<DNDSettingProtocol>(new DNDSettingProtocol(settingKey, eventSender, settingStorage));
+    return std::unique_ptr<DNDSettingProtocol>(
+        new DNDSettingProtocol(settingKey, eventSender, settingStorage, metricRecorder));
 }
 
 SetSettingResult DNDSettingProtocol::localChange(
@@ -83,6 +138,7 @@ SetSettingResult DNDSettingProtocol::localChange(
         if (!ok) {
             ACSDK_ERROR(LX("localChangeFailed").d("reason", "cannotApplyChange"));
             notifyObservers(SettingNotifications::LOCAL_CHANGE_FAILED);
+            submitMetric(m_metricRecorder, LOCAL_CHANGE_FAILED_METRIC, m_key, 1);
             return;
         }
 
@@ -90,10 +146,13 @@ SetSettingResult DNDSettingProtocol::localChange(
             ACSDK_ERROR(LX("localChangeFailed").d("reason", "cannotUpdateDatabase"));
             revertChange();
             notifyObservers(SettingNotifications::LOCAL_CHANGE_FAILED);
+            submitMetric(m_metricRecorder, LOCAL_CHANGE_FAILED_METRIC, m_key, 1);
             return;
         }
 
         notifyObservers(SettingNotifications::LOCAL_CHANGE);
+        submitMetric(m_metricRecorder, LOCAL_CHANGE_METRIC, m_key, 1);
+        submitMetric(m_metricRecorder, LOCAL_CHANGE_FAILED_METRIC, m_key, 0);
 
         this->m_eventSender->sendChangedEvent(value).get();
 
@@ -138,14 +197,19 @@ bool DNDSettingProtocol::avsChange(
         if (!ok) {
             ACSDK_ERROR(LX("avsChangeFailed").d("reason", "cannotApplyChange"));
             notifyObservers(SettingNotifications::AVS_CHANGE_FAILED);
+            submitMetric(m_metricRecorder, AVS_CHANGE_FAILED_METRIC, m_key, 1);
         } else if (!this->m_storage->storeSetting(m_key, value, SettingStatus::AVS_CHANGE_IN_PROGRESS)) {
             ACSDK_ERROR(LX("avsChangeFailed").d("reason", "cannotUpdateDatabaseValue"));
             notifyObservers(SettingNotifications::AVS_CHANGE_FAILED);
             value = revertChange();
+            submitMetric(m_metricRecorder, AVS_CHANGE_FAILED_METRIC, m_key, 1);
         } else {
             notifyObservers(SettingNotifications::AVS_CHANGE);
+            submitMetric(m_metricRecorder, AVS_CHANGE_FAILED_METRIC, m_key, 0);
         }
 
+        submitMetric(m_metricRecorder, AVS_CHANGE_METRIC, m_key, 1);
+
         /// We need to sent the report for failure or success case.
         this->m_eventSender->sendReportEvent(value);
 
@@ -197,10 +261,12 @@ bool DNDSettingProtocol::clearData() {
 DNDSettingProtocol::DNDSettingProtocol(
     const std::string& key,
     std::shared_ptr<SettingEventSenderInterface> eventSender,
-    std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage) :
+    std::shared_ptr<storage::DeviceSettingStorageInterface> settingStorage,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) :
         m_key{key},
         m_eventSender{eventSender},
-        m_storage{settingStorage} {
+        m_storage{settingStorage},
+        m_metricRecorder{metricRecorder} {
 }
 
 }  // namespace doNotDisturb
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
index bfe97ade..910731e7 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
@@ -13,6 +13,8 @@
  * permissions and limitations under the License.
  */
 
+#include <chrono>
+
 #include <rapidjson/error/en.h>
 #include <rapidjson/stringbuffer.h>
 #include <rapidjson/writer.h>
@@ -71,6 +73,9 @@ static const std::string DND_JSON_INTERFACE_VERSION = "1.0";
 /// Name for "enabled" JSON branch.
 static constexpr char JSON_KEY_ENABLED[] = "enabled";
 
+/// A timeout for an HTTP response when sending change events.
+static const std::chrono::seconds HTTP_RESPONSE_TIMEOUT(15);
+
 std::shared_ptr<DoNotDisturbCapabilityAgent> DoNotDisturbCapabilityAgent::createDoNotDisturbCapabilityAgent(
     const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender,
     const std::shared_ptr<settings::storage::DeviceSettingStorageInterface>& settingsStorage,
@@ -79,7 +84,8 @@ std::shared_ptr<DoNotDisturbCapabilityAgent> DoNotDisturbCapabilityAgent::create
     const acsdkManufactory::Annotated<
         avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
         avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface>& endpointCapabilitiesRegistrar,
-    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
     ACSDK_DEBUG5(LX(__func__));
 
     if (!exceptionSender || !messageSender || !settingsStorage || !shutdownNotifier || !endpointCapabilitiesRegistrar ||
@@ -94,7 +100,7 @@ std::shared_ptr<DoNotDisturbCapabilityAgent> DoNotDisturbCapabilityAgent::create
         return nullptr;
     }
 
-    auto dndCA = create(messageSender, settingsStorage, exceptionSender, connectionManager);
+    auto dndCA = create(messageSender, settingsStorage, exceptionSender, connectionManager, metricRecorder);
     if (!dndCA) {
         ACSDK_ERROR(LX("createDoNotDisturbCapabilityAgentFailed").m("null DoNotDisturb CapabilityAgent"));
         return nullptr;
@@ -140,11 +146,12 @@ std::shared_ptr<DoNotDisturbCapabilityAgent> DoNotDisturbCapabilityAgent::create
     const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender,
     const std::shared_ptr<settings::storage::DeviceSettingStorageInterface>& settingsStorage,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
-    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
     auto dndCA = std::shared_ptr<DoNotDisturbCapabilityAgent>(
         new DoNotDisturbCapabilityAgent(exceptionSender, messageSender, connectionManager));
 
-    if (!dndCA->initialize(settingsStorage)) {
+    if (!dndCA->initialize(settingsStorage, metricRecorder)) {
         ACSDK_ERROR(LX("createFailed").d("reason", "Initialization failed"));
         return nullptr;
     }
@@ -175,9 +182,10 @@ settings::SettingEventMetadata DoNotDisturbCapabilityAgent::getDoNotDisturbEvent
 }
 
 bool DoNotDisturbCapabilityAgent::initialize(
-    std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage) {
+    std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
     auto metadata = getDoNotDisturbEventsMetadata();
-    auto protocol = DNDSettingProtocol::create(metadata, shared_from_this(), settingsStorage);
+    auto protocol = DNDSettingProtocol::create(metadata, shared_from_this(), settingsStorage, metricRecorder);
     m_dndModeSetting = settings::Setting<bool>::create(false, std::move(protocol));
     return m_dndModeSetting != nullptr;
 }
@@ -289,6 +297,7 @@ void DoNotDisturbCapabilityAgent::doShutdown() {
         m_connectionManager->removeConnectionStatusObserver(shared_from_this());
     }
 
+    m_executor.waitForSubmittedTasks();
     m_executor.shutdown();
     m_dndModeSetting.reset();
 }
@@ -329,29 +338,69 @@ std::shared_future<MessageRequestObserverInterface::Status> DoNotDisturbCapabili
 }
 
 std::shared_future<bool> DoNotDisturbCapabilityAgent::sendChangedEvent(const std::string& value) {
-    std::promise<bool> promise;
+    ACSDK_DEBUG5(LX(__func__));
+    std::shared_ptr<std::promise<bool>> promise = std::make_shared<std::promise<bool>>();
     {
         std::lock_guard<std::mutex> guard(m_connectedStateMutex);
         if (!m_isConnected) {
             m_hasOfflineChanges = true;
-            promise.set_value(false);
-            return promise.get_future();
+            promise->set_value(false);
+            return promise->get_future();
         }
         m_hasOfflineChanges = false;
     }
 
-    // Sequentialize event processing so that no directive or another event would be handled while we sending this event
-    m_executor.submit([this, value]() {
-        MessageRequestObserverInterface::Status status = sendDNDEvent(EVENT_DONOTDISTURBCHANGED.name, value).get();
-        bool isSucceeded = MessageRequestObserverInterface::Status::SUCCESS == status ||
-                           MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT == status;
+    // capture-by-value dndModeSetting. (or optionally use a weak_ptr instead)
+    // this is needed to avoid a race condition where doShutdown() resets the m_dndModeSetting pointer 
+    // while the lambda executes, causing a segfault if m_dndModeSetting is dereferenced.
+    auto dndModeSetting = m_dndModeSetting;
 
-        if (!isSucceeded) {
-            sendDNDEvent(EVENT_REPORTDONOTDISTURB.name, m_dndModeSetting->get() ? "true" : "false");
+    // Sequentialize event processing so that no directive or another event would be handled while we sending this event
+    m_executor.submit([this, value, dndModeSetting, promise]() {
+        auto future = sendDNDEvent(EVENT_DONOTDISTURBCHANGED.name, value);
+        if (future.wait_for(HTTP_RESPONSE_TIMEOUT) == std::future_status::ready) {
+            auto httpResponse = future.get();
+            std::ostringstream oss;
+            oss << httpResponse;
+            ACSDK_DEBUG5(LX("sendChangedEventExecutor").d("eventName", EVENT_DONOTDISTURBCHANGED.name).d("status", oss.str()));
+
+            switch (httpResponse) {
+                case MessageRequestObserverInterface::Status::THROTTLED:
+                case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
+                case MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2:
+                case MessageRequestObserverInterface::Status::TIMEDOUT:
+                case MessageRequestObserverInterface::Status::INTERNAL_ERROR:
+                    // retry once but don't wait for response
+                    sendDNDEvent(EVENT_REPORTDONOTDISTURB.name, dndModeSetting->get() ? "true" : "false");
+                    promise->set_value(true);
+                    break;
+
+                case MessageRequestObserverInterface::Status::SUCCESS:
+                case MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED:
+                case MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT:
+                    promise->set_value(true);
+                    break;
+
+                case MessageRequestObserverInterface::Status::CANCELED:
+                case MessageRequestObserverInterface::Status::BAD_REQUEST:
+                case MessageRequestObserverInterface::Status::PENDING:
+                case MessageRequestObserverInterface::Status::NOT_CONNECTED:
+                case MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED:
+                case MessageRequestObserverInterface::Status::PROTOCOL_ERROR:
+                case MessageRequestObserverInterface::Status::REFUSED:
+                case MessageRequestObserverInterface::Status::INVALID_AUTH:
+                default:
+                    promise->set_value(false);
+                    break;
+            }
+        } else {
+            ACSDK_WARN(LX("sendChangedEventExecutor").m("sendEventFailed").d("reason", "noHTTPResponse"));
+            // retry once but don't wait for response
+            sendDNDEvent(EVENT_REPORTDONOTDISTURB.name, dndModeSetting->get() ? "true" : "false");
+            promise->set_value(true);
         }
     });
-    promise.set_value(true);
-    return promise.get_future();
+    return promise->get_future();
 }
 
 std::shared_future<bool> DoNotDisturbCapabilityAgent::sendReportEvent(const std::string& value) {
diff --git a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h
index 0893077c..69f3fdc5 100644
--- a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h
+++ b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h
@@ -109,7 +109,7 @@ public:
 
     /// @name Overridden @c CallStateObserverInterface methods
     /// @{
-    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) override;
+    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) override;
     /// @}
 
     /// @name Overridden @c DialogUXStateChanged methods.
@@ -190,7 +190,7 @@ private:
     /**
      * This function handles when the CallState has been changed.
      */
-    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state);
+    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo);
 
     /**
      * This function handles when the DialogUXState has been changed.
diff --git a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp
index 6ae2c522..9f9db72a 100644
--- a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp
+++ b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp
@@ -240,9 +240,9 @@ void MRMCapabilityAgent::onSpeakerSettingsChanged(
     m_executor.submit([this, type]() { executeOnSpeakerSettingsChanged(type); });
 }
 
-void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__).d("callState", callState));
-    m_executor.submit([this, callState]() { executeOnCallStateChange(callState); });
+    m_executor.submit([this, callState, displayInfo]() { executeOnCallStateChange(callState, displayInfo); });
 }
 
 void MRMCapabilityAgent::onDialogUXStateChanged(
@@ -305,7 +305,7 @@ void MRMCapabilityAgent::executeOnUserInactivityReportSent() {
 }
 
 void MRMCapabilityAgent::executeOnCallStateChange(
-    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__));
     bool isCurrentlyActive = CallStateObserverInterface::isStateActive(callState);
 
-- 
2.33.0

